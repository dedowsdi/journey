 vim: tw=80 sw=2 ts=2 et
-----------
2018.01.02:
    
bash:
  indirect expansion ${!var}
    var=foo ; foo=hoo; echo ${!var}

  ${parameter#word}, remove matching prefix as less as possible
  ${parameter##word}, remove matching prefix as much as possible

  ${parameter%word}, remove matching tail as less as possible
  ${parameter%%word}, remove matching tail as much as possible

  here string 
    <<<str

-----------
2018.01.03:

bash:
  IFS sequence of characters used to split fields. default to <space><tab><newline>

  "$*" = "$1c$2c$3..."
  "$@" = "$1"c"$2"c"$3"...

  array:
    indexed array works like vector
    declare -a l ; l=(a b c d e) ; echo ${#l[@]} ;  unset l[0] ; echo ${l[@]}

    associatived array works like map
    declare -A m; m[a]=A ; m[b]=B ; m[c]=C ; unset m[b] ; echo ${#m[@]} ; echo ${!m[@]} ; echo ${m[@]}

zsh:
  array:
    zsh array index starts at 1, unless KSH_ARRAYS option is set
    l=(a b c d e) ; echo ${#l[@]} ;  unset l[1] ; echo ${l[@]}

    typeset -A m; m[a]=A ; m[b]=B ; m[c]=C ; unset "m[b]" ; echo ${#m[@]} ; echo ${!m[@]} ; echo ${m[@]}

-----------
2018.01.06:

vim:
  winnr('$') get number of windows
  bufwinnr(winbufnr(winid)) convert winid to winnr
  use getwinvar() to retrieve window variable and option
  use getwininfo() to retreive window infor

-----------
2018.01.07:

vim:
  You can not set break point at anomymous function(numbered funcition). You should use normal
  function with dict postfix.
  use :function /pattern to search function

-----------
2018.01.08:

wsl:
  wsl doesn't support gui related stuff.

bash:
  grep -L ...  get files without match
  you can nest "" if the inner "" is used to quote sub command result
  !!:0  repeat last command, discard everything except 1st word

ag:
  ag use pcre(3) with multiline enabled search pattern.

linebreak:
  unix    LF   0A   \n
  windows CRLF 0D0A \r\n
  mac     CR   0D   \r
  Make sure you don't mix fileformat, some search patterns rely on it.
  you can use &filemormat option in vim to check fileformat.
  sometimes if your echo behaved weird, it might because your are handling a dos
  file and the "\r" cause echo to do weird stuff.

vim:
  gp paste below cursor, place cursor at end of newly pasted context
  in order to search literal string with line break, use
     substitute(escape(string, '\/?'), "\n", '\\n', 'g')
  replace string musbe be '\\n', '\n' won't work. It works like manually type /Ctrl-r=string
  when searching, \n is newline, \r is CR (carriage return = Ctrl-M = ^M) 
  when replacing, \r is newline, \n is a null byte (0x00).

-----------
2018.01.09:

bash:
  grep -F and ag -F are totally different,  grep -F interpret pattern as a list
  of new line seperated strings, each string will be used as a search pattern,
  any of which is to be matched seperately.  ag -F match pattern as whole
  string, including "newline".
  You can not use \n as line break in literal search, you must use the real
  linebreak character(0X0A for unix)

-----------
2018.01.09:

vim:
  shellescape(str) escape str to be used for shell command arg,
  ' => '\''
  \n and ! will be escaped once or twice
  %#will be escaped zero or once

  If you want to use str as literial match, leave \n and ! alone, but escape %#
  and | (if your ex command has -bar option) if you will use it'll be used in a
  ex command.

-----------
2018.01.10:

sed:
  by default, sed output all the processed text, use -n to suppress it
  sed took script from --expression or --file or the first non option argument
  if there has no -e or -f. 
  you can specify multiple input to sed, they will be combined together as a single giant input, you
  can also use -s to tell sed to treat them seperately.
  Commands within a script or script-file can be separated by semicolons (;) or newlines (ASCII 10).
  Multiple scripts can be specified with -e or -f options.

  all sed command follow this syntax:
    [addr]X[options]

vim:
  special line number in range:
    /{pattern}[/]  [/] is needed to seperate pattern from anything that follows
    ?{pattern}[?]  
    \/             use previous search pattern
    \?
    \&             use previous substitute pattern
    /pat1//pat2/   find line contain "pat2" after line containing "pat1", without moving the cursor

  range can be seperated with , or ;
    5;/pat2/       find line contain "pat2" after line 5, pat2 search will start after line 5

-----------
2018.01.12:

sed:
  sed address is very much alike vim range, except:
    blank range indicate whole file
    post ! after range is used to negate the sense of match

  sed use BRE by default, -e will switch to ERE

regex:
  backreference: \# reference previous # capturing group, \1 matches the exact
  same text that was matched by the first capturing group. 

gl:
  always clear depth if you depth test is enabled.
  
-----------
2018.01.13:

gl:
  lighting of normalmap is prefered to be calculated in tangent space, which
  means you have to transform light, camera into tangent space in vertex shader.
  Local viewer of light model has no meaning in tangent space lighting.

  Although it's easier to calculate normalmap lighting in view space, you only
  need to transfrom normal from tbn space to view space in fragment shader.

-----------
2018.01.14:

gl:
  for debug purpose, it'd better to get used to normal colors:

  normal      | color         | basic color name 
  ------------|-----------------------------------
  1,  0,  0   | 1,   0.5, 0.5 | light brown?
  0,  1,  0   | 0.5, 1,   0.5 | light lime?
  0,  0,  1   | 0.5, 0.5, 1   | light blue ?
  -1, 0,  0   | 0,   0.5, 0.5 | teal
  0,  -1, 0   | 0.5, 0,   0.5 | purple
  0,  0,  -1  | 0.5, 0.5, 0   | olive

  basic rgb colors:
    Black   #000000 (0,0,0)
    White   #FFFFFF (255,255,255)
    Red     #FF0000 (255,0,0)
    Lime    #00FF00 (0,255,0)
    Blue    #0000FF (0,0,255)
    Yellow  #FFFF00 (255,255,0)
    Cyan    #00FFFF (0,255,255)
    Magenta #FF00FF (255,0,255)
    Silver  #C0C0C0 (192,192,192)
    Gray    #808080 (128,128,128)
    Maroon  #800000 (128,0,0)
    Olive   #808000 (128,128,0)
    Green   #008000 (0,128,0)
    Purple  #800080 (128,0,128)
    Teal    #008080 (0,128,128)
    Navy    #000080 (0,0,128)


  yellow = red + green
  cyan = green + blue
  magenta = red + blue

-----------
2018.01.15:

gl:
  If your vertex attribute array looks weird, such as the w componnet is not 1 or the number of
  components is not right, you might forgot to enable this attribute array.

sed:
  you can specify number flag to replace only nth match.
  s/.../.../number

vim:
  bufexists works on full path name, tild path name, and relative path name
  There is no number flag in substitute, you can only do it with following regex:
  s/\v%((pattern).{-}){n-1th}\zspattern/replace pattern/

-----------
2018.01.16:

freeimage:
  FreeImage uses a BGR[A] pixel layout under a Little Endian processor (Windows, Linux) and uses a
  RGB[A] pixel layout under a Big Endian  processor (Mac OS X or any Big Endian Linux / Unix). 

-----------
2018.01.17:

lldb:
  Lldb 3.8 only support watchpoint for built in type?
  Faild to set watch point for glm::mat4[0][0], always complain failed to send
  gdb stuff.

vim:
  undo branches:
    normal undo(u) redo(ctrl-r) goes back and forward along current branch. When you undo something
    and make a change, vim will create a new undo branch for you.
    Every change you made is numbered, you can travel along it with g- and g+, or :earlier, :later,
    g- is the same as earlier 1, g+ is the same as g+. You can also goto specific change directly
    with :undo N (:undo N is totally different from :undo), if N is in current branch, current
    branch didn't change, otherwise, current branch is changed to branch that contains N (If
    multiple branches contain N, use the one with largest change number).
    :earlier {N}{[s|m|h|d]} works with time
    :earlier {N}f goto older text state {N} file writes before.
    :undolist will list head chagne of every branch.

  there is no way to paste literal linebreak directly, you must use = register
  to do this

-----------
2018.01.18:

vim:
  if command has -bar option, you must escape | if you want to use it as
  argument.
  ex command will expand % to current file, # to alternate file
  grep will use !shellcmd ? which means if you want to match literal linebrak,
  you must escape it.

  file search:
    downward search:
      ** matches only directory in file search, 
      **5 means maximum number of levels matched is 5

    upward search:
      usually used to search for a file
      /a/b/c/d;/a/b will search in:
        /a/b/c/d
        /a/b/c
        /a/b
      /a/b is called stop directory, it should be appended to previous path with
      a ';'. if you omit it, vim will search until root.
      e;/a/b  will search in (assume current dir is /a/b/c/d):
        /a/b/c/d/e
        /a/b/c/e
        /a/b/e

    combined search:
      **;/a/b wil search in(assume crrent dir is /a/b/c/d):
      /a/b/c/d/**
      /a/b/c/**
      /a/b/**

  'tags' : by default &tags = ./tags;,tags
    if cpoption doesn't include 'd' ./ will expand to path of current file.

  gl:
    it's totally legal to bind the same buffer to different target.

-----------
2018.01.18:

linux:
  check cpu :
    lscpu
    cat /proc/cpuinfo 
  check disk and partition :
    lsblk
    fdisk -l
  check disk filesystem:
    df -T
  check slot on mother board:
    lspci
  check cpu bit :
    getconf LONG_BIT 
  check memory :
    free
    cat /proc/meminfo  
  check memory hardware :
    dmidecode -t memory
  check bios :
    dmidecode -t bios
  check all DMI(desktop management interface) info
    dmidecode -q
  check mother board
    dmidecode | grep -A20 'System Information'
  check system info :
    uname -a
  check usb:
    lsusb
  check hardware:
    lshw

  iconv can be used to change character encoding

vim:
  :set change both global and local option
  :setglobal set global option
  :setlocal set local option
  setlocal option< set local value to it's global value
  set option<  remove local value, so global value will be used

  fileencodings : 
    when you edit an existing file in vim, vim will try fileencoding in
    'fileencodings' in sequence, utf-8 will be used if all failed, fileencoding
    will be set to an empty string, so you should put special encoding (such as
    ucs-bom)in the front part, and common encoding(such as latin1) in the back.
    fileencodings is ignored if ++enc option exists
    if fileencodings is empty, vim will use global fileencoding

  fileencoding :
    when you edit a new file, global fileencoding will be used. If fileencoding
    is empty, utf-8 will be used.  if fileencoding is not utf-8, conversion will
    be done when writting the file(via internal iconv).
  
  encoding:
    vim internal encoding, it's always utf-8

  ga : print ascii value
  g8 : print hex value
  8g8 : find illegal utf-8 byte sequence

-----------
2018.01.20:

vim:
  ctrl-\_e replace whole cmdline with expressiion, you might need getcmdtype(),
  getcmdline(), getcmdpos(), setcmdpos() to help you with it.

  help topic:
    prefix   example    context
    :        :h let     excmd
    none     :h r       normal mode
    v_       :h v_*     visualmode
    i_       :h i_*     insert mode
    c_       :h c_*     ex command line
    /        :h /*      search patterno
    '        :h '*'     option
    -        :h -*      vim argument
   you can use ctrl-v to insert the special key want to search help for that key

-----------
2018.01.20:

vim:
  search-offset:
    /pattern/[bse][num]   apply lines or characters offset
    /pattern0/;/patten1/  use /patten1/ as offset, search start after match of pattern0

bash:
  nl   add line number to output

-----------
2018.01.23:

vim:
  You can get all special character code in :digraph, or search digraph-table

c++:
  when you insert something at iter to a vector, if the vector needs to be
  reallocated, all iterators will be invalidated, otherwise only iteraters
  starts from iter will be invalidated.

-----------
2018.01.25:

bash:
  xargs took as much augument as possible per command line, unless you specify -n
  if you want to use xargs with itmes contain space:   
    print item lines | xargs -d "\n" -n1 cmd

  \ in double quotes escapes only $, `, ", \, or newline, otherwise it's removed.

-----------
2018.01.26:

gl:
  billboard: there are mainly 3 kinds of billboard
    0 : align billboard rotatoin to camera rotation
    2 : rotate z to center_to_camera, don't care about orientation.
    3 : look at camera from billboard center, use camera up as up.

  You can also create billboard just like you render 2d text.

  You can also create billboard by transform billboard center to ndc (the depth
  value is generated in the same ways as other renderable in the scene), and
  then define your billboard directly in ndc(If you want to create billboard in
  fixed size, this is an option).

vim:
  vim use b:current_syntax to guard syntax file loading.
  If want to just add or change some syntax to current syntax file, place you
  syntax file under runtimepath/after/syntax/, and don't set b:currentsyntax

-----------
2018.01.27:

c++:
  if you erase iter of list while you are looping, only the erased iter got
  invalidated, which means ++iter will fail, you need to do it like this:
    auto it = iter;
    ++it;
    l.erase(iter)

-----------
2018.01.28:

ssh:
  there are mainly two ways to use ssh:
    1: username,password, commonly used on unix system.
    2: public key authorization(commonly used in android system):
      use ssh-genkey to generate private and public key
      keep private key to your self, copy public key to server .ssh/authorized_keys

      ssh-keygen -t rsa -b 2048
      ssh-copy-id -i id_rsa.pub username@ip_address // no username for android

android:
  you can install termux in your android to use it like linux:
    sshd
    passwd


  termux use 8022 as default port for ssh.

linux:
  check dir or file space usage : du -hs /etc
  You can use deja-dup to bakup, restore.
  You can restore a single file or directory : as deja-dup --restore

  You can use grep -A to print more lines after match.

-----------
2018.01.29:

linux:
  daemon:
    A daemon is a computer program that runs as a background process in
    multitasking computer operating system. Traditionally the process names of a
    daemon end with the letter d.
    Daemon is not attached to a tty, which means you can list deamon process as:?
      ps -eo tty,pid,comm | grep ^?

    You can use initctrl to control init deamon?. 
      initctrl list
      initctrl status ssh-agent

  orphan process: parent dead, but still executing, adopted by init(pid 1).

  zombie(defunct) process : a process that has completed execution (via the exit
    system call) but still has an entry in the process table: it is a process in
    the "Terminated state". This occurs for child processes, where the entry is
    still needed to allow the parent process to read its child's exit status:
    once the exit status is read via the wait system call, the zombie's entry is
    removed from the process table and it is said to be "reaped". A child
    process always first becomes a zombie before being removed from the resource
    table. In most cases, under normal system operation zombies are immediately
    waited on by their parent and then reaped by the system – processes that
    stay zombies for a long time are generally an error and cause a resource
    leak. The kill command has no effect on zombie process.

  An orphan zombie process will be reaped automatically.

  terminal = tty = text input/output enviroment
  console = pyshical terminal

  shell is the outer most layer around the operating system kernel.
  There are two kinds of shell:
    command line interface(CLI).
    graphical user interface(GUI).
    
  there are two kinds of tty:
    hardware tty : one end connected to hardware, one end connected to software
    pesudo tty : both ends connected to software.

-----------
2018.01.30:

vim:
  If there exists multiple entries of the same line in quickfix list, and you
  want to make change to every quickfix entry, you need to revert the quickfix
  list first, otherwise only entry of the same line will will be changed
  correctly.

  v:register  |  the register in effect.
  v:char      |  character that was typed to trigger the abbreviation

  <expr> can be used in map or abbreviation
    :inoremap <expr> key expression  " evaluate expression as rhs
    :ab[breviate] [<expr>] [<buffer>] {lhs} {rhs}

git:
  If do something like :
    git checkout sha1
  You will be in 'detached head' state, git won't be able to handle you change
  in this state. You should always use
    git checkout -b newbranch sha1

gl:
  normal achieved from normal still needs to be normalized:
   // be very careful about this!!, not easay to debug, totally nightmare
    vec3 t_normal = normalize(texture(normal_map, fi.texcoord).xyz * 2 - 1); 

linux:
  there are two kinds of clipboard:
    CLIPBOARD SELECTION works as traditional clipboard.  according to + in vim
    PRMARY SELECTION works on last heightlight, pasted with middle mouse.
    according to * in vim.
    SECONDARY SELECTION was never used by me.
  You need some tool such xsel to connect tty and xwindow selection. :
    echo balabala  | xsel -i   # set primary selection to balabala
  If you are using neovim, you should install one of of this kind of tool.

  there has no clipboard in tty, but you can do it via x window xlipboard. 
    echo whatever | DISPLAY=:0 xsel -i
    DISPLAY=:0 xsel -o

-----------
2018.02.01:

linux:
  swap works likes virtual memory on windows.

  device:
    a device file or special file is an interface for a device driver that
    appears in a file system as if it were an ordinary file. They allow software
    to interact with a device driver using standard input/output system calls,
    which simplifies many tasks and unifies user-space I/O mechanisms.

  There are two general kinds of device files in Unix-like operating systems:
    character devices(not used in linux):
      provide unbuffered, direct access to the hardware device.

    block device:
      provide buffered access to hardware devices, and provide some abstraction
      from their specifics. Unlike character devices, block devices will always
      allow the programmer to read or write a block of any size (including
      single characters/bytes) and any alignment. 

  Pseudo-devices: 
    Device nodes on Unix-like systems do not necessarily have to correspond to
    physical devices. Nodes that lack this correspondence form the group of
    pseudo-devices.

  Some of the most commonly used (character-based) pseudo-devices include:
    /dev/null – accepts and discards all input; produces no output (always
                returns an end-of-file indication on a read)
    /dev/zero – accepts and discards all input; produces a continuous stream of
                NUL (zero value) bytes
    /dev/full – produces a continuous stream of NUL (zero value) bytes when
                read, and returns a "disk full" message when written to

    /dev/random and /dev/urandom – they produce a variable-length stream of
                                   pseudo-random numbers.

  In Unix-like operating systems, a loop device, vnd (vnode disk), or lofi (loop
  file interface) is a pseudo-device that makes a file accessible as a block
  device. such as:
    mount -o loop /media/balabala /dsfsdf/sdf.iso

  linux style file system:
    inode:
      inode is a data structure in a Unix-style file system that describes a
      filesystem object such as a file or a directory. Each inode stores the
      attributes and disk block location(s) of the object's data.Filesystem object
      attributes may include metadata (times of last change, access,
      modification), as well as owner and permission data.
      Every file has one inode.

    block:
      real file content, a file may take multiple blocks.

    directory:
      directy block stores child inode and their name(just like hard link),
      which means if you want to add/delete/rename a file in a directory, you
      need w privilege.

    link:
      hard link:
        simply add a new inode name pair in directory data block, no new inode
        created. You can only create hard link in the same filesystem. You can
        not create hard link for directory. 
      symbolic link:
        Add a new file, it's datablock is the target. It's a new file, it has
        it's own inode an datablock.

    number of hard links:
      a file has 1 hard link when it's created, it's stored in it's parent
      directory, it increases every time you create a hardlink for it. 

      a directory has 2 had link when it's created, one in it's parent
      directory, one in special entry '.', whose inode is the directory it self.
      it also increases everytime you create a child directory in it, as special
      entry '..' of child directory will point to it's parent, 

-----------
2018.02.02:
  linux:
    top:
      operation:
        o COMMAND=lantern   # filter command
        L                   # locate 
        k                   # kill
      top -n 1              # execute once and exit
      top -o %MEM           # sort by %MEM
    top detail is hard to remember, htop is much more user friendly.

    bash arithmetic works on integer only. you need bc to work on float:
      echo "scale=3; 1/100"|bc

  schedule commands:
    scheduled commands is done via cron deamon on linux.
    you can use crontab -e to schedule your commands. Or you can add commands to
    /etc/cron.daily/ to execute command in preset schedule.

  find default port for service:
    cat /etc/services

Multiples of bytes:
  Decimal    |           | Binary     |          |
  Value      | Metric    | Value      | IEC      | JEDEC
  1000^1	kB | kilobyte  | 1024^1	KiB | kibibyte | KB	kilobyte
  1000^2	MB | megabyte  | 1024^2	MiB | mebibyte | MB	megabyte
  1000^3	GB | gigabyte  | 1024^3	GiB | gibibyte | GB	gigabyte
  1000^4	TB | terabyte  | 1024^4	TiB | tebibyte | –
  1000^5	PB | petabyte  | 1024^5	PiB | pebibyte | –
  1000^6	EB | exabyte   | 1024^6	EiB | exbibyte | –
  1000^7	ZB | zettabyte | 1024^7	ZiB | zebibyte | –
  1000^8	YB | yottabyte | 1024^8	YiB | yobibyte | –

-----------
2018.02.03:
linux:
  you can use xinput to control touchboard:
    xinput list
    xinput --disable touchboardid
  
c++:
  always always initialize class member.

gl:
  if you change marcro that will change uniform size(such as light_count), you
  need to rebind all uniform locations.

-----------
2018.02.04:

vim:
  aw includes trailing  or leading(if it has not trailing ) white space. Be
  careful with this, it might cause problem.
  c-w_c-o close all windows except current one. just like :only

-----------
2018.02.06:

linux:
  use who to check logged users.
  

-----------
2018.02.07:

vim:
  :25   goto line 25
  :/pattern/ goto line match pattern, different from :normal! /pattern
  ycm search .ycm_extra_conf vim dir of current file untile root, be careful
  about this.

linux:
  change tty font:
    sudo dpkg-reconfigure console-setup

-----------
2018.02.09:

linux:
  The splash screen is the picture that you can see while Linux is booting.

  The framebuffer (fbdev) is a character device providing access to graphics
  hardware. 

  Although the Linux frame-buffer supports 256 (or more) colors, the Linux console
  driver does not; therefore, console applications are still limited to 16 colors
  on the Linux console, frame-buffer or not.

  change tty resolution:
    type vbeinfo or videoinfo in grub prompt to get supported resolution.(or use
    hwinfo --framebuffer)
    add following lines to /etc/default/grub
      GRUB_GFXMODE=1920x1080x32
      GRUB_GFXPAYLOAD_LINUX=keep

  always use max tty resolution:
      GRUB_GFXMODE=auto

  change tty text color:
    echo -en "\e]P0222222"
    # e]p is the "set color escape", color format is XRRGGBB

  get max color in current terminal:
    tput colors   # only 8 for tty, 256 for gnome terminal


-----------
2018.02.10:

c++:
  Internal linkage refers to everything only in scope of a translation unit.

  External linkage refers to things that exist beyond a particular translation
  unit. In other words, accessible through the whole program, which is the
  combination of all translation units.

-----------
2018.02.12:

c++:
  After a serious of yaw and pitch, your camera will be tilted.  You need to get
  current eye position and use look at to fix up. or.

math:
  inertial space:
    rotation only coordinate transform. 
    a_p1 = R * a;
    a_p2 = T * a_p1;

  sometimes it's necessary to do translate before rotation:
    a_p1 = T * a;   // can i call p1 space initrial_t space ?
    a_p2 = T * a_p1;

  create model view matrix with negative eye translation in world space:
    it's trivial to create model view by translation * rotation:
      mv_mat = translate(world_pos) * rotate(world rotation)
    if your world rotation changed, but you want to reserve your eye position:
      // it should be understood as intrinsic transform.
      mv_mat = rotate(new world rotation) * translate(-eye)

  rotate around y+:
    | c  0 s |
    | 0  1 0 |
    | -s 0 c |

  post translate:
    | A00   a01 | * | I t01 | = | .. A00*t01+a01    | =  A +   | 0 A00*t01   |
    | a10_t α11 |   | 0 1   |   | .. a10_t*t01+α11  |          | 0 a10_t*t01 |

    |  A00  | * t01 =  a0 * τ0 + a1 * τ1 + a2 * τ2
    | a10_t |
    
    ∴  A * T  =  | a0 a1 a2 a3+a0*τ0+a1*τ1+a2*τ2 |

  pre translate
    | I t01 | * | A00   a01 | = | A00+t01*a10_t a01+t01*α11 | 
    | 0 1   | * | a10_t α11 |   | ..                        | 
                              = A + | t01*a10_t t01*α11 | = A + | τ0*α30 τ0*α31 τ0*α32 τ0*α11|
                                    | 0         0       |       | τ1*α30 τ1*α31 τ1*α32 τ1*α11|
                                                                | τ2*α30 τ2*α31 τ2*α32 τ2*α11|
                                                                | 0      0      0      0     |

-----------
2018.02.16:

math:
  dot distribution:
    x_t·(y+z) = x_t·y + x_t·z
    (y+z)_t·x = y_t·x + z_t·x
    (x+y)_t·(x+y) = x_t·x + 2x_t·y + y_t·y

  laff matrix vector scalar greek alphabet:
    Matrix | vector | scalor | code    | note
    A      | a      | α      | code    | note
    B      | b      | β      | alpha   |
    C      | c      | γ      | beta    |
    D      | d      | δ      | gamma   |
    E      | e      | ε      | epsilon | ei is the ith unit basis vector
    F      | f      | φ      | phi     |
    G      | g      | ξ      | xi      |
    H      | h      | ν      | eta     |
    I      |        |        |         | identity matrix
    K      | k      | κ      | kappa   |
    L      | l      | λ      | lambda  |
    M      | m      | μ      | mu      | m(·) = row dimension
    N      | n      | ν      | nu      | ν is shared with V. n(·) = column dimension
    O      |        |        |         | not used
    P      | p      | π      | pi      |
    Q      | q      | θ      | theta   |
    R      | r      | ρ      | rho     |
    S      | s      | σ      | sigma   |
    T      | t      | τ      | tao     |
    U      | u      | υ      | upsilon |
    V      | v      | ν      | nu      | ν is shared with N
    W      | w      | ω      | omega   |
    X      | x      | χ      | chi     |
    Y      | y      | ψ      | psi     |
    Z      | z      | ζ      | zeta    |

  if you partition matrix by rows, use a_h_t(transpose a with hat) to represent it.

  given x∈ R_n, 
    x = Σ(i, 0, n-1, xi*ei)

  let L:R_n --> R_m be a linear transformation, given x∈ R_n, the result of y =
  L(x) is a vector in R_m, but then:
    y = L(x) = L(Σ(i, 0, n-1, χi*ei)) 
             = Σ(i, 0, n-1, L(χi*ei)) 
             = Σ(i, 0, n-1, χi*L(ei))
             = Σ(i, 0, n-1, χi*ai)  // let L(ei) = ai
             = Ax   // let A = | a0 a1 a2 .. am_1 |  //m_1 is m-1
    ∴ so any L(x) can be represented as A(x), ai = L(ei)
  
  ∵ A(αx) = αAx, A(x+y) = Ax+Ay
  ∴ A is linear

  ∴ A function f : R_n → R_m is a linear transformation iff it can be written as
    a matrix-vector multiplication.

-----------
2018.02.18:

linux:
  install dict:
    sudo add-apt-repository universe
    sudo apt install dict     # cli client to dictd server
    sudo apt install dictd    # server
    sudo apt install dict-gcide dict-wn dict-devil dict-moby-thesaurus  # database
    
-----------
2018.02.19:

c++:
  if your class is derived from template class, such as A<int>, and there is a
  method called foo() in A<int>, you can not access foo directly in your derived
  class, "foo" in derived class is a nondependent name, which mean compiler
  won't search it in A<int>, there are 3 ways to access foo:
    1. this->foo(). Since this is always implicitly dependent in a template,
       this->foo is dependent and the lookup is therefore deferred until the
       template is actually instantiated, at which point all base classes are
       considered
    2. A<int>::foo to access.
    3. call using A<int>::foo prior to foo();

-----------
2018.02.20:

vim:
  you can not execute ex command in normal!:
    :normal! vi}:d     " won't work
  
  you can do it like this:
    :normal! vi}
    :'<,'>d

math:
  matrix-matrix multiplication distributive:
    A(B+C) = AB + AC
    (B+C)A = BA + CA

  let A∈ R_mxn, let D denote a diagonal matrix:
    AD = |a0 a1 a2 ... an_1| D
       = |δ0*a0 δ1*a1 δ2*a2 ... δn_1*an_1|

    (DA) = | δ0*a0_h_t     |
           | δ1*a1_h_t     |
           |  ...          |
           | δn_1*an_1_h_t |

  if A, B ∈ R_n_n, and are both upper triangular matrix, then AB is also upper
  triangular matrix:
    C=AB
    assume i > j
      γij = a_h_i_t·bj
          = Σ(k, 0, n-1, αik*βkn_1 )
        ∵ A is upper triangular, 
        ∴ αik = 0 if k < i
    ∴ γij = Σ(k, i, n-1, αik*βkn_1 )
        ∵ B is upper triangular, 
        ∵ k >= i > j
        ∴ βkj = 0
    ∴ γij = 0

  if A, B ∈ R_n_n, and are both lower triangular matrix, then AB is also lower
  triangular matrix:

  if B = AA_t B is symmetric
    βij = a_h_i_t·a_h_j = a_h_j_t·a_h_i = βji
  if B = A_tA B is symmetric
    βij = ai_t·aj = aj_t·ai = βji

  rank1 update:
    A = A + αxx_t

-----------
2018.02.21:

math:
  gaussian transform. L_j
    I 0        0 0 ... 0
    0 1        0 0 ... 0   // the jth row
    0 -λ_j+1,j 1 0 ... 0
    0 -λ_j+2,j 0 1 ... 0
    0 .        . . .   0
    0 .        . .  .  0
    0 .        . .   . 0
    0 -λ_m-1,j 0 0 ... 1

  L_j*A equals A except for i > j, (L_j*A)_h_i_t = a_h_i_t - a_h_j_t * λ_i,j

  use LU factorization to solve Ax = b :
    L is unit lower trianglular matrix, U is upper trianglular matrix.
    A = LU, U = L_inv*A, L_inv will the the final gaussian transform matrix
    use gaussian transform to generate L and U col by col(current L col is the same as
    negative col in gaussian transform). so 
      L = L_n-1···L_2*L_1*L_0

    forward substitution:
      solve Lz = b.  (z = apply gaussian transform to the right hand side)
      z = L_inv * b (the algorithm is nearly the same as LU factoriazation,
                    except b is an vector)

    backward substitution:
      solve Ux = z

windows:
  powershell:
     create a new “Current user, Windows PowerShell ISE” profile:
       if (!(Test-Path -Path $PROFILE ))
       { New-Item -Type File -Path $PROFILE -Force }

-----------
2018.02.22:

math:
  If Gaussian elimination with row exchanges (LU factorization with pivoting)
  completes with an upper triangular system that has no zero diagonal
  coefficients, then for all right-hand side vectors, b, the linear system Ax =
  b has a unique solution, x.

  permutation vector:
    k_j ∈ {0,1..,n-1}, for 0<=j<=n-1.   k_i=k_j ==> i = j
    p = (k_0, k_1, ...k_n-1)_t 

  permutation matrix:
    P = P(p) = | e_k_0_t   |
               | e_k_1_t   |
                    .
                    .
                    .
               | e_k_n-1_t |

    P is the identity matrix with its rows(or cols) rearranged as indicated by
    the permutation vector (k 0 , k 1 , . . . , k n−1 ).

  pivot matrix:
    P(j) is a pivot matrix, it's result of swap 0 and jth row of I.

  if in ith step of gaussian elimination, the ith item of current row is 0, you
  can not do gaussian elimination, you must swap row, that's what pivot matrix
  used for:
    PA = LU
    PAx = Pb
    LUx = Pb
    Lz = Pb
    Ux = z

  gaussian elimation will fail if no row can be found that puts a nonzero on the
  diagonal(except the last one, if the appended one is also zero).

  if A is invertible:
   • A is nonsingular.
   • A_inv exists.
   • AA_inv = A_inv*A = I.
   • A represents a linear transformation that is a bijection.
   • Ax = b has a unique solution for all b ∈ R_n .
   • Ax = 0 implies that x = 0.
   • Ax = ej has a solution for all j ∈ {0, . . . , n − 1}.
   • The determinant of A is nonzero: det(A) != 0.
   • LU with partial pivot doesn't break down.
   • C(A) = R_n.  // ==> m=n ==> a0···an-1 is independent
   • A has linearly independent columns
   • N(A) = {0}.
   • rank(A) = n.

  inverse of special matrix:
    A = | 0 1 | A_inv = | 0 1 |
        | 1 0 |         | 1 0 |

    | α_0,0 α_0,1 |      | α_1,1 -α_0,1 |   
    | α_1,0 α_1,1 |_inv =| -α_1,0 α_0,0 |* (α_0,0*α_1,1 − α_1,0*α_0,1)

    | L_00   0    |        | L_00_inv               0      |
    | l_10_t λ_11 |_inv =  | -l_10_t*L_oo_inv/λ_11  1/λ_11 |
    so if lower triangular matrix has no 0 on it's diagnal, it's invertible.

    | U_00   u_01 |        | U_00_inv  -U_00_inv*u_01/υ_11 |
    | 0      υ11  |_inv =  | 0         1/υ_11              |
    so if upper triangular matrix has no 0 on it's diagnal, it's invertible.

    | I 0    0 |        | I  0    0 |
    | 0 1    0 |        | 0  1    0 |
    | 0 l_21 0 |_inv =  | 0 -l_21 0 |

  A_t_i = A_i_t
    AA_i = I
    A_i_t * A_t = I
    A_t_i = A_i_t

-----------
2018.02.23:

math:
  gauss-jordan elimination:
    AX = B
    transform A to I

  Matrix A is said to be symmetric positive definite (SPD) if
    • A is symmetric; and
    • x_T*Ax > 0 for all nonzero vectors x ∈ R_n.

  Cholesky factorization theorem:
    Let A ∈ R_n×n be a symmetric positive definite matrix. Then there exists a
    lower triangular matrix L ∈ R_n×n such that A = LL_T . If the diagonal
    elements of L are chosen to be positive, this factorization is unique.

-----------
2018.02.24:

math:

  row echelon form :  
                        | α00 α01 α02 ··· | 
                        | 0   α11 α12 ··· | 
                        | 0   0   α22 ··· | 
                        | 0   0   0   ··· | 

  reduced-echelon form :
                         | 1 0 0 ··· |
                         | 0 1 0 ··· |
                         | 0 0 1 ··· |
                         | 0 0 0 ··· |

  pivot : number in diagonal

  number of solutions of Ax=b:
    use gauss (jordan) elimination to transform |A b|:
      if there exists 0 = β != 0,  it has no solution
      if no pivot is 0, it has one solution.
      if some pivots is 0, it has infinite solution.

    to solve Ax=b with infinite solution:
      use gauss (jordan) elimination to transform |A b|
      find a specific solution x_s by settiong free variable to 0
      find a non-trivial solution x_n to Ax=0 by setting free variable vector to
      unit base vector one by one
      the general solution will be x_s + β0x_n0 + β1x_n1 + ···
      
  a vector space is a subset, S, of R_n with the following properties:
    • 0 ∈ S (the zero vector of size n is in the set S)
    • If v, w ∈ S then (v + w) ∈ S
    • If α ∈ R and v ∈ S then αv ∈ S
  S is closed under addition and scalar multiplication.

  vector space of R_n is also called subsapce of R_n

  Let A ∈ R_m×n . Then the column space of A equals the set
  { Ax | x ∈ R_n } . It is denoted by C(A), it's a subspace of R_m

  Let A ∈ R_m×n . Then the row space of A equals the set
  { A_tx | x∈ R_n } . It is denoted by R(A), it's a subspace of R_n

  Let A ∈ R_m×n , x ∈ R_n , and b ∈ R_m. Then Ax = b has a solution if and only if b ∈ C(A).

  Let A ∈ R_m×n . Then the set of all vectors x ∈ R_n that have the property
  that Ax = 0 is called the null space of A and is denoted by N(A) = {x|Ax = 0}.

  Let {v0 , v1 , · · · , vn−1 } ⊂  R_m . Then the span of these vectors, Span{v 0
  , v1 , · · · , vn−1 }, is said to be the set of all vectors that are a linear
  combination of the given set of vectors, which is a subspace of R_m.

  If V = |v0 v1 ··· vn−1|, then Span(v0,v1 , . . . , vn−1 ) = C(V).

  A spanning set of a subspace S is a set of vectors {v0 , v1 , . . . , vn−1 }
  such that Span({v0 , v1 , . . . , vn−1 }) = S.

  Let {v0 , . . . , vn−1 } ⊂ R_m. Then this set of vectors is said to be
  linearly independent if χ0v0 + χ1v1 + · · · + χn−1vn−1 = 0 implies that χ0
  = · · · = χn−1 = 0. A set of vectors that is not linearly independent is said
  to be linearly dependent.

  if a set of vector is said to be linearly independent, none of these vector
  can be written as linear combination of the other vectors.

  Let {a0 , . . . , an−1 } ⊂ R_m and let A = | a0 ··· an−1 |. Then the vectors
  {a0 , . . . , an−1 } are linearly independent if and only if N(A) = {0}.

  Let {a0 , a1 , . . . , an−1 } ∈ R_m and n > m. Then these vectors are linearly
  dependent.

  Let S be a subspace of R_m . Then the set {v0 , v1 , · · · , vn−1 } ⊂ R_m is
  said to be a basis for S if:
    {v0 , v1 , · · · , vn−1 } are linearly independent 
    Span{v0 , v1 , · · · , vn−1 } = S.

  Let S ⊂ R_m . Then S contains at most m linearly independent vectors.

  Let S be a nontrivial subspace of R m . (In other words, S != {0}.) Then
  there exists a basis {v0 , v1 , . . . , vn−1 } ⊂ R_m such that Span(v0 , v1 ,
  . . . , vn−1 ) = S.

  Let S be a subspace of R_m and let {v0 , v1 , · · · , vn−1 } ⊂ R_m and {w0 ,
  w1 , · · · , wk−1 } ⊂ R_m both be bases for S.  Then k = n. In other words,
  the number of vectors in a basis is unique.

  The dimension of a subspace S equals the number of vectors in a basis for that
  subspace.

  Let A ∈ R_m×n . The rank of A equals the number of vectors in a basis for the
  column space of A. We will let rank(A) denote that rank.

  Let {v0 , v1 , · · · , vn−1 } ⊂ R_m be a spanning set for subspace S and
  assume that vi equals a linear combination of the other vectors. Then {v0 , v1
  , · · · , vi−1 , vi+1 , · · · , vn−1 } is a spanning set of S.

  Let {v0 , v1 , · · · , vn−1 } ⊂ R_m be linearly independent and assume that
  {v0 , v1 , · · · , vn−1 } ⊂ S where S is a subspace. Then this set of vectors
  is either a spanning set for S or there exists w ∈ S such that {v0 , v1 , · ·
  · , vn−1 , w} are linearly independent.

linux:
  man hier  # filesystem hierarchy

-----------
2018.02.25:

math:

1inch = 2.54cm
1foot = 12 inch = 30.48cm
9.68m = 31.75853feet ≈ 32feet
1yard = 3feet = 91.44cm
1mile = 5280feet = 1609.344m
1 league = 4,828.0417 meter (distance a man can cover in 1 hour)

1pound = 0.45359237kg


-----------
2018.02.26:

math:

任一排列中， 当某两个元素的先后次序与标准次序不同时， 就说有1个逆序.
一个排列中所有你虚的总数叫这个排列的逆序数。
逆序数为奇数的排列叫做奇排列，偶数的叫做偶排列。

det(A) = Σ(-1)^t(α_0,p0*α_1,p1*···α_n-1,p_n-1) 
det(A) = Σ(-1)^t(α_p0,0*α_p1,1*···α_pn-1,n-1) 
(there are n! different permutations, t is number of inversions)

if D is a diagonal matrix:
  det(D) = δ_0,0 * δ_1,1 * ··· δ_n-1,n-1

if D is reverse diagonal matrix
  det(D) =(-1)^(n*(n-1)/2)*δ_0,0 * δ_1,1 * ··· δ_n-1,n-1

if U is upper triangular matrix:
  det(U) = υ_0,0 * υ_1,1 * ··· υ_n-1,n-1

对换: 在排列中， 将任意两个元素对掉， 其余元素不动
相邻对换: 将相邻两元素对换。

1个排列中的任意两个元素对换，排列改变奇偶性。

det(A) = det(A_t)
det(A) = -1 * det(swap i, j row(col) of A)
det(A) = 0 if a_i = k*a_j, i != j
if B = A, b_i = k*a_i, det(B) = k*det(A)
if a_i = b_i + c_i
det(A) = det(|a0 a1 ... b_i ... an-1|) + det(|a0 a1 ... c_i ... an-1|)

A = | A_00   0    |,  det(A) = det(A_00) * det(A_11)
    | A_10   A_11 |

minor m_ij = det(delete ith row, jth col of A)
cofactor c_ij = (-1)^(i+j)(m_ij)

det(A) = a_i,0*det(c_i,0) + a_i,1*det(c_i,1) + ...a_i,n-1*det(c_i,n-1)

vandermonde:
  A = 
      | 1         1         ... 1           |
      | x_0       x_1       ... x_n-1       |
      | x_0^2     x_1^2     ... x_n-1^2     |
      | ...       ...       ... ...         |
      | ...       ...       ... ...         |
      | x_0^(n-1) x_1^(n-1) ... x_n-1^(n-1) |

  det(A) = Π_n>i>j>=0(x_i - x_j)

a_i,0*det(A_c_j,0) + a_i,1*det(A_c_j,1) + ...a_i,n-1*det(A_c_j,n-1) = 0 if i != j

law of cramer:
  if det(A) != 0, Ax=b has unique solution, x_i = det( a_i = b)  / det(A)

if Ax = b has 0 or more than 1 solutions, det(A) = 0

-----------
2018.02.27:

vim:
  visual-block replace will replace every screen char with the same char.
  use \%V to match inside the gv area. 
    assume you visual area is "foo bar"
      /\%Vfoo.*bar  will match "foo bar"
      /\%Vfoo.*bar\%V will match "foo ba", no "r"
      /\%Vfoo.*ba\%Vr will match "foo bar"

  
math:
  det(λA) = λ^n*det(A)
  det(AB) = det(A) * det(B)
    det( | A  0 | ) = det(A) * det(B)  // assume A B are both nxn squre matrix
         | -I B |
                    = det( | A  AB | ) // c1 + c1 * B
                           | -I 0  |
                    = (-1) ^n * det ( | -I 0   | ) // swap rows n times
                                      | A  AB  |
                    = (-1)^n * det(-I) * det(AB)
                    = (-1)^n * (-1)^n * det(AB)
                    = det(AB)
  det(AB) = det(BA) = det(A)* det(B)

  let A be nxn square matrix, it's adjugate matrix is:
    A_a = | c_0,0   c_1,0   ...   C_n-1,0   |
        = | c_0,1   c_1,1   ...   C_n-1,1   |
        = | ...     ...     ...   ...       |
        = | ...     ...     ...   ...       |
        = | c_0,n-1 c_1,n-1 ...   C_n-1,n-1 |

    A*A_a = A_a*A = det(A) I
    A_i = A_a / det(A)

  let A = PLP_i
      A^2 = PL^2P_i
      A^n = PL^nP_i

  A_t*A = 0 iff A = 0
    
-----------
2018.02.28:

math:
  basic matrix row transform:
   E(i,j)   a_t_i <-> a_t_j, 
   E(i(k))  a_t_i = k * a_t_i
   E(ij(k)) a_t_i += k * a_t_j

   E(i,j)_i = E(i,j)
   E(i(k))_i = E(i(k))/k
   E(ij(k))_i = E(ij(-k))

  if A after finite basic trasform become B, A〜B
  A〜B ==> B〜A
  A〜B && B〜C ==> A〜C
  Any matrix A can be transformed into standard form via basic transform:  
    | I 0 |
    | 0 0 |, rank(A) = dimension of I

  A~r~B iff PA = B, P is nonsingular
  A_i exists iff A~r~I
  A~c~B iff AQ = B, Q is nonsingular
  A〜B iff PAQ = B, P,Q is non singular

  let A be a square matrix, A_i exists iff A = P1P2...., Pi is bais matrix

  let A be a mxn matrix, pick k rows and columns(k<=m && k<=n), the crossing k^2
  elements elements will form a k order determinent, 称作A的k阶子式.

  设在A中有一个不为0的r阶子式D， 且所有r+1阶子式(存在的话)全为0,
  那么D称为A的最高阶非0子式， r = rank(A) or R(A), 0矩阵的秩为0

  0<=R(A)<=min(m,n)
  R(A) = R(A^t)
  if A is n squre, R(A) = n iff det(A) != 0
  if A〜B , then R(A) = R(B)
  if P,Q is nonsingular, R(PAQ) = R(A)
  max(R(A), R(B)) <= R(A,B) <= R(A) + R(B)
  R(A+B)<=R(A)+R(B)
  R(AB)<=min(R(A), R(B))
  if let A be mxn, B be nxl AB=0 then R(A) + R(B) <=n

  Ax=b, (b∈ R_n) has 0 solusion if R(A) < R(A, b)
             1 solution if R(A) = R(A,b) = n
             n solution if R(A) = R(A,b) < n

  AX=B has solutions iff R(A) = R(A, B)

-----------
2018.03.01:

math:
  {x=(x0,x1....xn-1)_t | a0x0+a1x1+....an-1xn-1 = b }
  叫做n唯向量空间R_n中的n-1唯超平面

  if b1,b2,...bl are linear combination s of a1,a2,...am, R(|b1,b2...|) <=
  R(|a1,a2...|)

  如果 a0,a1...an-1 和 b0,b1,..bn-1 能相互线性表示， 则两个向量组等价

  a0,a1..an-1 is linearly dependent iff  R(|a0,a1..an-1|) < n; a0,a1...an-1 is linearly
  independent iff R(|a0,a1...an-1|) = n

  最大无关组所包含的向量个数称为向量组的秩

  R(A) = R(a0,a1....an-1) = R(a_h_0, a_h_1, .....a_h_n-1)

  设mxn矩阵A的秩R(A) = r, 则n元齐次线性方程组Ax=0的解集S的秩R(S) = n-r

  R(A_tA) = R(A)

-----------
2018.03.02:

math:
  Let V, W ⊂ R_n be subspaces. Then V and W are said to be orthogonal if and only
  if v ∈ V and w ∈ W implies that v_t*w = 0.

  Given subspace V ⊂ R_n , the set of all vectors in R_n that are orthogonal to
  V is denoted by V^⊥ (pronounced as “V-perp”).

  Let A ∈ R_m×n . Then R(A)⊥ N(A).

  Let A ∈ R_m×n . Then every x ∈ R_n can be written as x = x_r + x_n where x_r ∈
  R(A) and x_n ∈ N(A).

  ∵ Ax_r = Ax_r + 0 = A(x_r + x_n) = Ax
  ∴ We conclude that if Ax = b has a solution, then there is a x_r ∈ R(A) such
  that Ax_r = b.

  Let A ∈ R m×n . Then A is a one-to-one, onto mapping from R (A) to C ( A ).

  Given A ∈ R_m×n the left null space of A is the set of all vectors x such that
  x_t*A = 0, Clearly, the left null space of A equals the null space of A_T .

  Let A ∈ R_m×n . Then the left null space of A is orthogonal to the column
  space of A and the dimension of the left null space of A equals m − r, where r
  is the dimension of the column space of A.

  If A ∈ R_m×n(m need not equal to n) has linearly independent columns, then
  A_t*A is nonsingular (equivalently, has an inverse, A_t*A*x̂ = A_t*b has a
  solution for all b, etc.).

  Let A ∈ R_m×n, b ∈ R_m , and x ∈ R_n and assume that A has linearly
  independent columns. Then the solution that minimizes the length of the vector
  b − Ax is given by x̂ = (A_t*A)_i*A_t*b.

  if Ax=b has no solution, b !∈  C(A), assume z∈ C(A) and b = z + w, inorder to
  minimize ‖b-z‖, wo let w⊥ z, which means w∈ N(A_t) which means:
    A_t*w = 0
    A_t(b-z) = 0
    A_t*z = A_t*b
    A_t*A*x̂ = A_t*b
    x̂ = (A_t*A)_i*A_t*b

    z = Ax̂ = A*(A_t*A)_i*A_t*b  //proj of b on C(A)

    The orthogonal projection of b onto C(A)⊥ is given by 
      b − z = [I − A(A_t*A)_i*A_t]b.

  Let A ∈ R_m×n . If A has linearly independent columns, then A† = (A_t*A)_i*A_t
  is called the (left) pseudo inverse. Note that this means m ≥ n and A†*A =
  (A_t*A)_i*A_t*A = I.

-----------
2018.03.03:

linux:
  get number of cores:   getconf _NPROCESSORS_ONLN
  make in multiple cores : make -j $(getconf _NPROCESSORS_ONLN)
  
-----------
2018.03.05:

math: 
  Let q0 , q1 , . . . , qk−1 ∈ R_m . Then these vectors are (mutually)
  orthonormal if for all 0 ≤ i, j < k :
    qi_t * qj = 1   if i == j
    qi_t * qj = 0   otherwise

  Let a0 , a1 , . . . , ak−1 ∈ R m be linearly independent vectors and let q0 ,
  q1 , . . . , qk−1 ∈ R m be the result of Gram- Schmidt orthogonalization.
  Then Span({a0 , a1 , . . . , ak−1 }) = Span({q0 , q1 , . . . , qk−1 }).

  A matrix Q ∈ R_m×n has mutually orthonormal columns if and only if Q_t*Q = I.
  A matrix Q ∈ R_m×n has mutually orthonormal rows if and only if Q*Q_t = I.

-----------
2018.03.06:

math:
  QR factorization:
    (a0 a1 ...an-1) = (q0 q1 ... qn-1) * | ρ_0,0   ρ_0,1   ... ρ_0,n-1   |
                                         | 0       ρ_1,1   ... ρ_1,n-1   |
                                         | 0       ...     ... ...       |
                                         | 0       0       ... ρ_n-1,n-1 |
    in k th column:
      for p = 0...k-1
        ρ_p,k = qp_t * ak
      ak_⊥  = ak - Σ_p_0_k-1(ρ_p,k * q_p)
      ρ_k,k = ‖ak_⊥ ‖  
      q_k = ak_⊥ /ρ_k,k

  to solve Ax ≈ b
    x = (A_t*A)_i*A_t *b
      = ((QR)_t * QR )_i * (QR)_t * b
      = (R_t*R)_i * R_t*Q_t*b
      = R_i*Q_t*b
    Rx = Q_t*b

google:
  http://www.being.org.cn/tool/google.htm#8.3
  multiple keyworkd :  a [+] b 
  exclude b :  a -b
  or :  a OR b
  sentence : "this is a sentence"
  search in specific site : a site:sina.com
  search filetype : a filetype:pdf
  search url with keyword : inurl:keyword_in_url a
  search title with keyword : intitle:keyword_in_title a
  search everything linked to specific web page : link:www.sina.com.cn

  image search support + - OR site and filetype

linux:
  select last field of cut:
    ag --nogroup -o '^[ \t]*namespace\s*\w+' --cpp | rev | cut -d ' ' -f 1 | rev | sort | uniq > namespaces

git:
  sync fock:
    git remote add upstream remote_address
    git fetch remote
    git checkout master
    git merge upstream/master
    git push

-----------
2018.03.07:

math:
  conpoment of b in direction of a:
    u = a_t*b*a/(a_t*a)

vim:
  syntax region is valid even end match does't exist
  syn region name start=/a/ skip=/c/ end=/b/ 

  you can manage continas in cluster which can be updated by other users
    syn cluster clusterName contains=...
    syn match xgroup ..... contains=@clusterName " fetch contains from cluster
    syn keyword new_item ...  " create new group
    syn cluster add=new_item contained  " newly create group can be contained in xgroup

----------
2018.03.08

math:
  if Ax = λx, scalars λ that satisfy it for nonzero vector x are known as
  eigenvalues while the nonzero vectors is knows as eigenvectors. (λ,x) is said
  to be an eigenpair.

  to solve this, rearrange it as (A-λI)x = 0, A must be square, (A-λI) must be
  singular. x∈ N(A-λI)

  the set of all vectors x that satisfy Ax = λx is a subspace. every vector in
  this subspace except 0 is an eigenvector.

  Eigenpairs for diagnal matrix are given by (δ0,e0), (δ1,e1), · · · , (δn−1, en−1)

  The eigenvalues of upper or lower triangular matrix are α0,0, α1,1,...αn-1,n-1

c++:
  if you really want to define your template class or template function in
  source file without include it in head file, you can do something like this in
  the end of source
  file:
    template class ClassName<SpecificType0>;
    template class ClassName<SpecificType1>;
    ...
    template class ClassName<SpecificTypen>;
    void define_template_function(){
      void func<SpecificType0();
      void func<SpecificType1();
      ...
      void func<SpecificType2();
    }
  it will cause compiler to compile these particular types, so the associated
  class member functions will be available at link time.

----------
2018.03.09

math:
  let A be nxn matrix, if X_iAX = Λ, the matrix X is said to diagnalize matrix
  A. rank(X) = n.

  Matrices for which such a matrix X does not exists are called defective
  matrix.

  Given A ∈ R_n×n ,
  p_n (λ) = det(A − λI) = λ^n + γ_n−1*λ^n−1 + · · · + γ_1*λ + γ_0 
  for some coefficients γ_0, γ_1 , . . . , γ_n−1 ∈ R.

  The set of all roots of p_n(λ), which is the set of all eigenvalues of A, is
  denoted by Λ(A) and is called the spectrum of matrix A.

  Given A ∈ R_n×n , p_n(λ) = det(A − λI) is called the characteristic
  polynomial.

  The characteristic polynomial can be factored as 
  p_n(λ) = det(A − λI) = (λ − λ 0 )^n_0*(λ − λ_1)^n_1 · · · (λ − λ_k−1 )^n_k−1 ,
  where n0 + n1 + · · · + nk−1 = n and nj is the root λ j , which is known
  as the (algebraic) multiplicity of eigenvalue λ_j .

c++:
  you don't need virtual destructor unless you will destroy derived class with
  base class pointer.

linux:
  xargs -I conflicits with -n ?
    types='BOOK BODY'
    # following command will not print BOOK BODY on seperate lines
    echo $types | xargs -I {} -n 1 bash -cx 'echo {}' 

  redirect each execution of xargs:
    ... | xargs -I {} bash -c ' ... > ..'


----------
2018.03.10

math:
  jordan block has eigenvalue λ of algebraic multiplicity k, but geometric
  multiplicity one (it has only one linearly independent eigenvector).

    J_k(λ) =  | λ 1 0 ... 0 0 |
              | 0 λ 1 ... 0 0 |
              | 0 0 λ ... 0 0 |
              | ...       0 0 |
              | 0 0 0 ... λ 1 |
              | 0 0 0 ... 0 λ |
    Λ(J) = {λ}

  The geometric multiplicity of an eigenvalue λ equals the number of linearly
  independent eigenvectors that are associated with λ.

  Let A ∈ R_n×n and A_i,i are a square matrices. Then Λ(A) = Λ(A_0,0 ) ∪ Λ(A_1,1
  ) ∪ · · · ∪ Λ(A_N−1,N−1 ).

  Let A ∈ R_n×n be symmetric, λ_i != λ_j , Ax_i = λ_i*x_i and Ax_j = λ_j*x_j
  then xi_t*x_j = 0

  Let A ∈ R n×n be symmetric. Then its eigenvalues are real valued.

  Let Ax = λx and k ≥ 1. A^k*x = λ^k*x

  A ∈ R_n×n is nonsingular if and only if 0 !∈  Λ(A).

linux:
  use wc to count lines words or bytes

  use cmp compare files byte by byte

  use comm to cmpare files line by line (must be sorted)
    comm -23 file1 file2  # print uniq item in file1
    comm -13 file1 file2  # print uniq item in file2
    comm -12 file1 file2  # print common item in file1 and file2

  uniq -cd sorted  # find duplicated lines in a file

  read from file line by line:
    while IFS= read -r variable ; do
      ...
    done;<file
  
  proces substitution:
    comm -23 <(sort file0|uniq) <(sort file1|uniq)

----------
2018.03.11

c++:
  change data alignment:
    #pragma pack(push)
    #pragma pack(1)

    struct Data{
      ...
    }

    #pragma pack(pop)

linux:
  use xxd to dump hex or revert

----------
2018.03.12

linux:
  print hex
    echo $((16#ff))
    echo $((0xff))
  print oct
    echo $((8#77))
    echo $((077))

vim:
  count item:
    :%s/item//gn

----------
2018.03.14

vim:
  shift m lines 5 times
  :>>>>>m

qt:
  you can connect signal to another signal

  qt automatically removes all connections involving an object when the object
  is deleted. although you can manually do it with disconnect

  if a signal has more parameters than the slot it is connected to, the
  additional parameters are simply ignored.

  One of Qt's major achievements has been the extension of C++ with a mechanism
  for creating independent software components that can be bound together
  without any component knowing anything about the other components it is
  connected to.  The mechanism is called the meta-object system, and it provides
  two key services: signalsŔslots and introspection.

  meta-object system:
    The Q_OBJECT macro declares some introspection functions that must be
    implemented in every QObject subclass: metaObject(), tr(), qt_metacall(),
    and a few more.

    Qt's moc tool generates implementations for the functions declared by
    Q_OBJECT and for all the signals.

    QObject member functions such as connect() and disconnect() use the
    introspection functions to do their work.
  
----------
2018.03.15

vim:
  a and i is the same on blank line.

qt:
  After creating the user interface, setupUi() will automatically connect any
  slots that follow the naming convention on_objectName_signalName() to the
  corresponding objectName's signalName() signal

  Qt's parentŔchild mechanism is implemented in QObject. When we create an
  object (a widget, validator, or any other kind) with a parent, the parent adds
  the object to the list of its children.  When the parent is deleted, it walks
  through its list of children and deletes each child. The children themselves
  then delete all of their children, and so on recursively until none remain.
  The parent-child mechanism greatly simplifies memory management, reducing the
  risk of memory leaks. The only objects we must call delete on are the objects
  we create with new and that have no parent.  And if we delete a child object
  before its parent, Qt will automatically remove that object from the parent's
  list of children.  
  
  For widgets, the parent has an additional meaning: Child widgets are shown
  within the parent's area. When we delete the parent widget, not only does the
  child vanish from memory, it also vanishes from the screen.

----------
2018.03.16

qt4:
  The parent-child relationship doesn't mean the same thing for dialogs as for
  other widgets. A dialog is always a window in its own right, but if it has a
  parent, it is centered on top of the parent by default. A child dialog also
  shares its parent's taskbar entry.

  A modeless window is one that runs independently of any other windows in the
  application.

  A modal window is a window that pops up when invoked and blocks the
  application, preventing any other processing or interactions from taking place
  until the window is closed.

  A dialog is modeless if it's invoked using show() (unless we call setModal()
  beforehand to make it modal); it is modal if it's invoked using exec().

----------
2018.03.17

qt4:
  The top-left pixel of a Qt widget is located at position (0, 0), and the
  bottom-right pixel is located at (width() - 1, height() - 1).

linux:
  print available locales:
    locale -a

----------
2018.03.20

qt4:
  draw a pixel at x,y with antialiasing, the pixel center is at x+0.5, y+0.5
  draw a pixel at x,y with antialiasing, following pixels will be colored grey:
    (x-1, y-1)
    (x-1, y)
    (x, y-1)
    (x, y)
    this is 4 pixels surrounding x,y

  there are two sets of coordinates in qt:
    logical coordinate:
      you specify your geometry in this coordinate
    physical coordinate:
      the real window coordinates

  boundary of logical coordinates, works similar like ortho projection in opengl:
    paint->window(x,y,width,height)
  
  viewport in qt works similar as viewport like opengl:
    paint->setViewport(x,y,with,height)

----------
2018.04.03

linux:
  use im-confg to swtich fcitx or ibus.
  sort -h can sort someting like house number nicely.

----------
2018.04.03

math:
  0C = 32F
  100C = 212F
  which means 1C change is equal to 1.8F change
  so to change from F to C:
    (x-32)/1.8
  to change from C to F
    x*1.8 + 32

----------
2018.04.07

linux:
  change login shell to zsh:
    chsh -s $(which zsh)

----------
2018.04.10

linux:
  you can use pushd, popd to use directory stack.
  dirs will print everythign in the directory stack.

----------
2018.04.13

linux:
  vim:
    use byzanz-record to record gui animation.
    use ttyrec to record tty screen animation, then use ttygif to convert
    video record to gif.

----------
2018.04.26

qt4:
  editor widget created by item delegate in listwidget will be removed
  immediately if lose focus.

  setGeometry has no meaning in a layout.

  backgound color and property like that can be changed via stylesheet.

----------
2018.04.26

qt4:
  A dialog is always a top-level widget, which means you must specify global
  coordinates to position it. but if it has a parent, its default location is
  centered on top of the parent's top-level widget (if it is not top-level
  itself).

vim:
  viml string doesn't support negative index.

----------
2018.05.03

git:
  search deleted file:
    git log --all --full-history -- **/filename

----------
2018.05.05

vim:
  autoload function only exists when it's called, which means you can't test if
  an autoload functions exits like this:  exists(*plug#func)

linux:
  use ffempg to convert video format
  ffempt -i input.avi output.mp4

----------
2018.05.09

bash:
  expand variable twice:
    file=$(eval echo $file) # $file might be some variable

----------
2018.05.10

bash:
  Words of the form $'string' are treated specially. The word expands to
  "string", with backslash-escaped characters replaced as specified by the ANSI
  C standard. It is a ksh93 syntax also supported by bash, zsh, mksh and FreeBSD
  sh.

  always use array to store command line options with special characters.
    optoins="--id 'seyda neen'"
    et $options # this will generate erryr, 'seyda neen' will be split into
    'seyda and neen'

----------
2018.05.11
bash:
  compgen -W wordlist -- word 

  worldlists:
    worldlist will be treated as current typing words. single quote needs to be
    escaped, because worldlist treated it as starting quote around string:
      "a b'c d" will be split into "a"  "bc d" because bash think you might be typing "b'c d'"

    splited words will be expanded(just like echo splitedWord, no extra quote):
      x=y
      y=z
      compgen -W "\$$x"  # will generate z

    in bash "abc" can be typed in following ways(" works just like '):
      abc
      a''bc
      a'b'c
      a'bc'
      ab'c'

    which means following compgen will generate the same result
      compgen -W "abc" "a"
      compgen -W "abc" "a'"
      compgen -W "abc" "a'b"
      compgen -W "abc" "ab"
      compgen -W "abc" "ab'"

    if you have escaped ' in your splited word:
      compgen -W "a\'bc" "a'b" # generate nothing, impossible to continue 
                               # from a'b to generate a'bc (keep in mind, it
                               # needs to be expanded again)
      compgen -W "a\'bc" "a'"  # good to go, a''\'bc

    if you really want to complete "a'bcdef" from "a'b":
      compgen -W "a\'bcdef" "a\'b" # you must escape ' in both wordlist and
                                   # word!! in your script

    the same rule apply to \:
      assume you want to generate "a\\bcd" from "a\\b",
        a\b    -----> ab
        a\\b   -----> a\b
        a\\\\b -----> a\\b

      so you must replace \ with \\\\ in both wordlist and word. Again, keep in
      mind, splited wordlist and word need to be expand again, use the rule of
      echo word, no extra quotes.

    remember this: compgen complete possible typing !!! 

bash:
  word split:
    word splitting only happens when something expaned
    explicit null
      x='' # $x will be treated as empty string
    implicit null
      x=   # $x will be nothing 

----------
2018.05.13

vim:
  unamed regiser always point to the last used register.
    gv"sy              " chagne the last used register to s
    let @s='whatever'  " @" is equal to whatever, not something you copied into
                       " s register in the 1st line.

c++:
  be very careful with std::function:
    std::function<const std::string&(const void*) > totally accepts
    [](const void*)->std::string
    this can cause local reference problem, total night mare.
  
----------
2018.05.14

c++:
  pod must not be derived class
  
----------
2018.05.15

c++:
  don't put space between macro function name and (

----------
2018.05.16

qt4:
  you can not edit a table item with invalid variant data.
  
----------
2018.05.23

c++:
  you can not specialize nested template class without specialize outer class.
  But a partial specialization of a nested class is allowed.

----------
2018.05.26

lldb:
  sometimes if you failed to set breakpoint on a function, it might because it's
  never called in the entire application.

----------
2018.07.02

linux:
  showkey -a  // print key code

----------
2018.07.03

vim:
  ctrl-e can be replaced with 1ctrl-d, 1ctrl-d will set 'scroll' to 1 untile you
  call another #ctrl-d or reenter the buffer.

----------
2018.07.04

linux:
  chang gnome default application:
    edit /etc/gnome/defaluts.list

----------
2018.07.05

vscode:
  vscode cpp plugin failed to search default path if you use
  compile_commands.json

----------
2018.07.06

jq:
  '.array[] | whatever '    # whatever will operator on every item in array

gl:
  linewidth won't scale in viewport

----------
2018.07.07

c++:
  only lambda with blank catpure can be converted to c function
  you don't need capture static variable, you can use them directly.

  g@  will set `[ and `] to motion selection start and end. '@' register will be
      motion text

----------
2018.08.15

c++:
  you can define a macro in the same name as a global function. As the macro get
  expanded, the global function will never be used.

----------
2018.08.18

hsb(hsv) and hsl:
  they are similar, but not the same.
  hue part is exactly the same.
       black    white
  hsb  *,*,0    *,0,100
  hsl  *,*,0    *,*,100

----------
2018.09.11

osg:
  make sure you specify array binding when you set it to geometry.

----------
2018.09.11

osg:
  if you want to use 2d project on xy plane, make sure you set camera's
  allowEventFocus to false.

----------
2018.10.04

cpp:
  if you place object directly into container such as vector, be very very
  careful if you use pointer to such object, when vector space reallocated, all
  poiner wile be invallidated.

glsl:
  pow(x,y) only works for positive x

----------
2018.10.15

freeimage:
  some image use 8 bpp, but it might be color index.
  I should always convert image to 32bits before i use it in opengl.

----------
2018.10.26

cpp:
  You can use obj.*&Class::variableName to access obj.variableName.
  eg:
      template <class T, class S, class C>
      const S& Container(const std::priority_queue<T, S, C>& q) {
        struct HackedQueue : private std::priority_queue<T, S, C> {
          static const S& Container(const std::priority_queue<T, S, C>& q) {
            // q.c won't work, as it's protected
            return q.*&HackedQueue::c;
          }
        };
        return HackedQueue::Container(q);
      }

----------
2018.10.30

cpp:

named return value optimization (NRVO) (copy elision) is commonly implemented by
compiler(don't have to). It's preferable to return by value, even in c++11.

-----------
2018.11.2

cpp:
  
  IB: Implementation-defined Behaviour. The standard leaves it up to the
  particular compiler/platform to define the precise behaviour, but requires
  that it be defined.

  Using implementation-defined behaviour can be useful, but makes your code less portable.

  UB: Undefined Behaviour. The standard does not specify how a program invoking
  undefined behaviour should behave. Also known as "nasal demons" because
  theoretically it could make demons fly out of your nose.

  ADL: argument dependent lookup
  You don’t have to qualify the namespace for functions if one or more argument
  types are defined in the namespace of the function.

-----------
2018.11.2

gl:
  The contents of the back buffer become undefined after a swap.

-----------
2018.11.5

cpp:
  you can not return raw array with fixed size, but you can return std::array.

opengl:
  a buffer texture is simply a way for the shader to directly access a large
  array of data, generally larger than uniform buffer objects allow.

linux:
  use simple screen recorder to record screen video.

-----------
2018.11.8

gl:
  you must use multisample texture if you want to enable multisample durint
  rtt.:
     glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);
     glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGBA8, width, height, false);
     glBindFramebuffer(GL_FRAMEBUFFER, fbo);
     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
     GL_TEXTURE_2D_MULTISAMPLE, tex, 0)

  you can sample multisample texture like this:
    uniform int texSamples;
    uniform sampler2DMS tex;

    vec4 textureMultisample(sampler2DMS sampler, ivec2 coord)
    {
        vec4 color = vec4(0.0);

        for (int i = 0; i < texSamples; i++)
            color += texelFetch(sampler, coord, i);

        color /= float(texSamples);

        return color;
    }

  it's quite bulky, you might want to use default framebuffer and
  glCopyTexImage2D instead.

-------------
2018.11.13
cpp:
  int a = 'a';
  const char& b = a;
  ++a;
  std::cout << b;
  // will output 'a', because there is a temporary char that is bound to b,
  whose life time is expended to the life time of b.

--------------
2018.11.14
cpp:
  division is slowr than multiplication, but lots of compiler will optimize a
  literal constant express, some even optimize for variables.

prefix sum operation is an algorithm that, given an array of input values,
computes a new array where each element of the output array is the sum of all of
the values of the input array up to (and optionally including) the current array
element. A prefix sum operation that includes the current element is known as an
inclusive prefix sum, and one that does not is known as an exclusive prefix sum.

DMA: direct memory access

--------------
2018.11.17

gl:
  by default, gl_FragCoord starts at (0.5, 0.5),  this can be change by layout
  qualifier.

--------------
2018.11.18

cpp:
  be careful about stuff defined directly in src file, if it doesn't have
  internal linkage, you might get multiple difiniton error.

--------------
2018.11.26

vim:
  don't input space between event in autocmd

--------------
2018.11.27

cpp:
  becareful about std::accumulate(..., init), init is a template parameter, use
  specific type, otherwise the result might be rounded
  ternary operator has very low precedence, it'd better to group them with
  parenthesis.

--------------
2018.11.28

cpp:
  lifetime of temporary object will be extened by the first const reference
  bound to it, it's destoryed after the life time of that const reference
  expired, be very very careful about this, some function such as std::min or
  std::max use const reference arg and return const renference , if you call
  them with temporary object, the temporary object's life time will be extended
  by the const reference arg, not the return one, it will be destoryed after
  std::min finished, and it cause UB, it will be a nightmare.

  std::min and std::max always return the 1st one if a and b are equivalence.
  use std::minmax instead if that's not what you want

--------------
2018.12.03

cpp:
  if you want, you can put do something like
    int type<T>::static_variable = 5;
  in template header file, it won't violate ODL. It's kind of "inline"

  captureless lambda types are always implicitly convertible to functoin
  pointer. If you absolutely need the function-pointer convertion to happen, add
  a unary + before []. (there is no unary+ operator for lambda type, but there
  is unary+ operator for ponter type, this trick deosn't work on msvc, because
  there have 4 different calling convensions)

  to distinguish value category:
    xvalue is expiring value, it must involves &&
    xvalue + prvalue = rvalue
    xvalue + lvalue = glvalue

---------------
2018.12.04

cpp:
  during vector memory reallocation, the contents are moved if their move
  constructor is noexcept.

  after c++11, it always takes constant time to compare size() and 0 for all stl
  container, why?

  reserve does notheing if new capacity is not greater then current
  you can use shink_to_fit (might reallocate) or
  vector(vec.begin(), vec.end()).swap(vec) to reduce capacity.

  there is no guarantee that capacity is actually brought down exactly to size.
  Capacity is really up to your STL implementation. But with these techniques,
  it will be as small as it can get.

  unamed object is created and destroyed immediately.

  if you want you dan define inline multiple times, as long as they are all the
  same.

  dont return const pointer type, ultimate function call will be an rvalue, and
  rvalues of non-class type cannot be const, meaning that const will be ignored
  anyway

  names in template base classes are ignored in C++(because you might
  specilize template base to exclude that name), you must use this->to include
  them back

---------------
2018.12.06
cpp:
   assignment is right-associative

   copy constructor will call parent copy constructor if you don't provider one,
   copy assignment do nothing for parent part.

linux:
  stop x server:
    sudo service lightdm stop
    sudo init 3
