 vim: tw=80 sw=2 ts=2 et
-----------
2018.01.02:
    
bash:
  indirect expansion ${!var}
    var=foo ; foo=hoo; echo ${!var}

  ${parameter#word}, remove matching prefix as less as possible
  ${parameter##word}, remove matching prefix as much as possible

  ${parameter%word}, remove matching tail as less as possible
  ${parameter%%word}, remove matching tail as much as possible

  here string 
    <<<str

-----------
2018.01.03:

bash:
  IFS sequence of characters used to split fields. default to <space><tab><newline>

  "$*" = "$1c$2c$3..."
  "$@" = "$1"c"$2"c"$3"...

  array:
    indexed array works like vector
    declare -a l ; l=(a b c d e) ; echo ${#l[@]} ;  unset l[0] ; echo ${l[@]}

    associatived array works like map
    declare -A m; m[a]=A ; m[b]=B ; m[c]=C ; unset m[b] ; echo ${#m[@]} ; echo ${!m[@]} ; echo ${m[@]}

zsh:
  array:
    zsh array index starts at 1, unless KSH_ARRAYS option is set
    l=(a b c d e) ; echo ${#l[@]} ;  unset l[1] ; echo ${l[@]}

    typeset -A m; m[a]=A ; m[b]=B ; m[c]=C ; unset "m[b]" ; echo ${#m[@]} ; echo ${!m[@]} ; echo ${m[@]}

-----------
2018.01.06:

vim:
  winnr('$') get number of windows
  bufwinnr(winbufnr(winid)) convert winid to winnr
  use getwinvar() to retrieve window variable and option
  use getwininfo() to retreive window infor

-----------
2018.01.07:

vim:
  You can not set break point at anomymous function(numbered funcition). You should use normal
  function with dict postfix.
  use :function /pattern to search function

-----------
2018.01.08:

wsl:
  wsl doesn't support gui related stuff.

bash:
  grep -L ...  get files without match
  you can nest "" if the inner "" is used to quote sub command result
  !!:0  repeat last command, discard everything except 1st word

ag:
  ag use pcre(3) with multiline enabled search pattern.

linebreak:
  unix    LF   0A   \n
  windows CRLF 0D0A \r\n
  mac     CR   0D   \r
  Make sure you don't mix fileformat, some search patterns rely on it.
  you can use &filemormat option in vim to check fileformat.
  sometimes if your echo behaved weird, it might because your are handling a dos
  file and the "\r" cause echo to do weird stuff.

vim:
  gp paste below cursor, place cursor at end of newly pasted context
  in order to search literal string with line break, use
     substitute(escape(string, '\/?'), "\n", '\\n', 'g')
  replace string musbe be '\\n', '\n' won't work. It works like manually type /Ctrl-r=string
  when searching, \n is newline, \r is CR (carriage return = Ctrl-M = ^M) 
  when replacing, \r is newline, \n is a null byte (0x00).

-----------
2018.01.09:

bash:
  grep -F and ag -F are totally different,  grep -F interpret pattern as a list
  of new line seperated strings, each string will be used as a search pattern,
  any of which is to be matched seperately.  ag -F match pattern as whole
  string, including "newline".
  You can not use \n as line break in literal search, you must use the real
  linebreak character(0X0A for unix)

-----------
2018.01.09:

vim:
  shellescape(str) escape str to be used for shell command arg,
  ' => '\''
  \n and ! will be escaped once or twice
  %#will be escaped zero or once

  If you want to use str as literial match, leave \n and ! alone, but escape %#
  and | (if your ex command has -bar option) if you will use it'll be used in a
  ex command.

-----------
2018.01.10:

sed:
  by default, sed output all the processed text, use -n to suppress it
  sed took script from --expression or --file or the first non option argument
  if there has no -e or -f. 
  you can specify multiple input to sed, they will be combined together as a single giant input, you
  can also use -s to tell sed to treat them seperately.
  Commands within a script or script-file can be separated by semicolons (;) or newlines (ASCII 10).
  Multiple scripts can be specified with -e or -f options.

  all sed command follow this syntax:
    [addr]X[options]

vim:
  special line number in range:
    /{pattern}[/]  [/] is needed to seperate pattern from anything that follows
    ?{pattern}[?]  
    \/             use previous search pattern
    \?
    \&             use previous substitute pattern
    /pat1//pat2/   find line contain "pat2" after line containing "pat1", without moving the cursor

  range can be seperated with , or ;
    5;/pat2/       find line contain "pat2" after line 5, pat2 search will start after line 5

-----------
2018.01.12:

sed:
  sed address is very much alike vim range, except:
    blank range indicate whole file
    post ! after range is used to negate the sense of match

  sed use BRE by default, -e will switch to ERE

regex:
  backreference: \# reference previous # capturing group, \1 matches the exact
  same text that was matched by the first capturing group. 

gl:
  always clear depth if you depth test is enabled.
  
-----------
2018.01.13:

gl:
  lighting of normalmap is prefered to be calculated in tangent space, which
  means you have to transform light, camera into tangent space in vertex shader.
  Local viewer of light model has no meaning in tangent space lighting.

  Although it's easier to calculate normalmap lighting in view space, you only
  need to transfrom normal from tbn space to view space in fragment shader.

-----------
2018.01.14:

gl:
  for debug purpose, it'd better to get used to normal colors:

  normal      | color         | basic color name 
  ------------|-----------------------------------
  1,  0,  0   | 1,   0.5, 0.5 | light brown?
  0,  1,  0   | 0.5, 1,   0.5 | light lime?
  0,  0,  1   | 0.5, 0.5, 1   | light blue ?
  -1, 0,  0   | 0,   0.5, 0.5 | teal
  0,  -1, 0   | 0.5, 0,   0.5 | purple
  0,  0,  -1  | 0.5, 0.5, 0   | olive

  basic rgb colors:
    Black   #000000 (0,0,0)
    White   #FFFFFF (255,255,255)
    Red     #FF0000 (255,0,0)
    Lime    #00FF00 (0,255,0)
    Blue    #0000FF (0,0,255)
    Yellow  #FFFF00 (255,255,0)
    Cyan    #00FFFF (0,255,255)
    Magenta #FF00FF (255,0,255)
    Silver  #C0C0C0 (192,192,192)
    Gray    #808080 (128,128,128)
    Maroon  #800000 (128,0,0)
    Olive   #808000 (128,128,0)
    Green   #008000 (0,128,0)
    Purple  #800080 (128,0,128)
    Teal    #008080 (0,128,128)
    Navy    #000080 (0,0,128)


  yellow = red + green
  cyan = green + blue
  magenta = red + blue

-----------
2018.01.15:

gl:
  If your vertex attribute array looks weird, such as the w componnet is not 1 or the number of
  components is not right, you might forgot to enable this attribute array.

sed:
  you can specify number flag to replace only nth match.
  s/.../.../number

vim:
  bufexists works on full path name, tild path name, and relative path name
  There is no number flag in substitute, you can only do it with following regex:
  s/\v%((pattern).{-}){n-1th}\zspattern/replace pattern/

-----------
2018.01.16:

freeimage:
  FreeImage uses a BGR[A] pixel layout under a Little Endian processor (Windows, Linux) and uses a
  RGB[A] pixel layout under a Big Endian  processor (Mac OS X or any Big Endian Linux / Unix). 

-----------
2018.01.17:

lldb:
  Lldb 3.8 only support watchpoint for built in type?
  Faild to set watch point for glm::mat4[0][0], always complain failed to send
  gdb stuff.

vim:
  undo branches:
    normal undo(u) redo(ctrl-r) goes back and forward along current branch. When you undo something
    and make a change, vim will create a new undo branch for you.
    Every change you made is numbered, you can travel along it with g- and g+, or :earlier, :later,
    g- is the same as earlier 1, g+ is the same as g+. You can also goto specific change directly
    with :undo N (:undo N is totally different from :undo), if N is in current branch, current
    branch didn't change, otherwise, current branch is changed to branch that contains N (If
    multiple branches contain N, use the one with largest change number).
    :earlier {N}{[s|m|h|d]} works with time
    :earlier {N}f goto older text state {N} file writes before.
    :undolist will list head chagne of every branch.

  there is no way to paste literal linebreak directly, you must use = register
  to do this

-----------
2018.01.18:

vim:
  if command has -bar option, you must escape | if you want to use it as
  argument.
  ex command will expand % to current file, # to alternate file
  grep will use !shellcmd ? which means if you want to match literal linebrak,
  you must escape it.

  file search:
    downward search:
      ** matches only directory in file search, 
      **5 means maximum number of levels matched is 5

    upward search:
      usually used to search for a file
      /a/b/c/d;/a/b will search in:
        /a/b/c/d
        /a/b/c
        /a/b
      /a/b is called stop directory, it should be appended to previous path with
      a ';'. if you omit it, vim will search until root.
      e;/a/b  will search in (assume current dir is /a/b/c/d):
        /a/b/c/d/e
        /a/b/c/e
        /a/b/e

    combined search:
      **;/a/b wil search in(assume crrent dir is /a/b/c/d):
      /a/b/c/d/**
      /a/b/c/**
      /a/b/**

  'tags' : by default &tags = ./tags;,tags
    if cpoption doesn't include 'd' ./ will expand to path of current file.

  gl:
    it's totally legal to bind the same buffer to different target.

-----------
2018.01.18:

linux:
  check cpu :
    lscpu
    cat /proc/cpuinfo 
  check disk and partition :
    lsblk
    fdisk -l
  check disk filesystem:
    df -T
  check slot on mother board:
    lspci
  check cpu bit :
    getconf LONG_BIT 
  check memory :
    free
    cat /proc/meminfo  
  check memory hardware :
    dmidecode -t memory
  check bios :
    dmidecode -t bios
  check all DMI(desktop management interface) info
    dmidecode -q
  check mother board
    dmidecode | grep -A20 'System Information'
  check system info :
    uname -a
  check usb:
    lsusb
  check hardware:
    lshw

  iconv can be used to change character encoding

vim:
  :set change both global and local option
  :setglobal set global option
  :setlocal set local option
  setlocal option< set local value to it's global value
  set option<  remove local value, so global value will be used

  fileencodings : 
    when you edit an existing file in vim, vim will try fileencoding in
    'fileencodings' in sequence, utf-8 will be used if all failed, fileencoding
    will be set to an empty string, so you should put special encoding (such as
    ucs-bom)in the front part, and common encoding(such as latin1) in the back.
    fileencodings is ignored if ++enc option exists
    if fileencodings is empty, vim will use global fileencoding

  fileencoding :
    when you edit a new file, global fileencoding will be used. If fileencoding
    is empty, utf-8 will be used.  if fileencoding is not utf-8, conversion will
    be done when writting the file(via internal iconv).
  
  encoding:
    vim internal encoding, it's always utf-8

  ga : print ascii value
  g8 : print hex value
  8g8 : find illegal utf-8 byte sequence

-----------
2018.01.20:

vim:
  ctrl-\_e replace whole cmdline with expressiion, you might need getcmdtype(),
  getcmdline(), getcmdpos(), setcmdpos() to help you with it.

  help topic:
    prefix   example    context
    :        :h let     excmd
    none     :h r       normal mode
    v_       :h v_*     visualmode
    i_       :h i_*     insert mode
    c_       :h c_*     ex command line
    /        :h /*      search patterno
    '        :h '*'     option
    -        :h -*      vim argument
   you can use ctrl-v to insert the special key want to search help for that key

-----------
2018.01.20:

vim:
  search-offset:
    /pattern/[bse][num]   apply lines or characters offset
    /pattern0/;/patten1/  use /patten1/ as offset, search start after match of pattern0

bash:
  nl   add line number to output

-----------
2018.01.23:

vim:
  You can get all special character code in :digraph, or search digraph-table

c++:
  when you insert something at iter to a vector, if the vector needs to be
  reallocated, all iterators will be invalidated, otherwise only iteraters
  starts from iter will be invalidated.

-----------
2018.01.25:

bash:
  xargs took as much augument as possible per command line, unless you specify -n
  if you want to use xargs with itmes contain space:   
    print item lines | xargs -d "\n" -n1 cmd

  \ in double quotes escapes only $, `, ", \, or newline, otherwise it's removed.

-----------
2018.01.26:

gl:
  billboard: there are mainly 3 kinds of billboard
    0 : align billboard rotatoin to camera rotation
    2 : rotate z to center_to_camera, don't care about orientation.
    3 : look at camera from billboard center, use camera up as up.

  You can also create billboard just like you render 2d text.

  You can also create billboard by transform billboard center to ndc (the depth
  value is generated in the same ways as other renderable in the scene), and
  then define your billboard directly in ndc(If you want to create billboard in
  fixed size, this is an option).

vim:
  vim use b:current_syntax to guard syntax file loading.
  If want to just add or change some syntax to current syntax file, place you
  syntax file under runtimepath/after/syntax/, and don't set b:currentsyntax

-----------
2018.01.27:

c++:
  if you erase iter of list while you are looping, only the erased iter got
  invalidated, which means ++iter will fail, you need to do it like this:
    auto it = iter;
    ++it;
    l.erase(iter)

-----------
2018.01.28:

ssh:
  there are mainly two ways to use ssh:
    1: username,password, commonly used on unix system.
    2: public key authorization(commonly used in android system):
      use ssh-genkey to generate private and public key
      keep private key to your self, copy public key to server .ssh/authorized_keys

android:
  you can install termux in your android to use it like linux.
  termux use 8022 as default port for ssh.

linux:
  check dir or file space usage : du -hs /etc
  You can use deja-dup to bakup, restore.
  You can restore a single file or directory : as deja-dup --restore

  You can use grep -A to print more lines after match.

-----------
2018.01.29:

linux:
  daemon:
    A daemon is a computer program that runs as a background process in
    multitasking computer operating system. Traditionally the process names of a
    daemon end with the letter d.
    Daemon is not attached to a tty, which means you can list deamon process as:?
      ps -eo tty,pid,comm | grep ^?

    You can use initctrl to control init deamon?. 
      initctrl list
      initctrl status ssh-agent

  orphan process: parent dead, but still executing, adopted by init(pid 1).

  zombie(defunct) process : a process that has completed execution (via the exit
    system call) but still has an entry in the process table: it is a process in
    the "Terminated state". This occurs for child processes, where the entry is
    still needed to allow the parent process to read its child's exit status:
    once the exit status is read via the wait system call, the zombie's entry is
    removed from the process table and it is said to be "reaped". A child
    process always first becomes a zombie before being removed from the resource
    table. In most cases, under normal system operation zombies are immediately
    waited on by their parent and then reaped by the system ‚Äì processes that
    stay zombies for a long time are generally an error and cause a resource
    leak. The kill command has no effect on zombie process.

  An orphan zombie process will be reaped automatically.

  terminal = tty = text input/output enviroment
  console = pyshical terminal

  shell is the outer most layer around the operating system kernel.
  There are two kinds of shell:
    command line interface(CLI).
    graphical user interface(GUI).
    
  there are two kinds of tty:
    hardware tty : one end connected to hardware, one end connected to software
    pesudo tty : both ends connected to software.

-----------
2018.01.30:

vim:
  If there exists multiple entries of the same line in quickfix list, and you
  want to make change to every quickfix entry, you need to revert the quickfix
  list first, otherwise only entry of the same line will will be changed
  correctly.

  v:register  |  the register in effect.
  v:char      |  character that was typed to trigger the abbreviation

  <expr> can be used in map or abbreviation
    :inoremap <expr> key expression  " evaluate expression as rhs
    :ab[breviate] [<expr>] [<buffer>] {lhs} {rhs}

git:
  If do something like :
    git checkout sha1
  You will be in 'detached head' state, git won't be able to handle you change
  in this state. You should always use
    git checkout -b newbranch sha1

gl:
  normal achieved from normal still needs to be normalized:
    // be very careful about this!!, not easay to debug, totally nightmare
    vec3 t_normal = normalize(texture(normal_map, fi.texcoord).xyz * 2 - 1); 

linux:
  there are two kinds of clipboard:
    CLIPBOARD SELECTION works as traditional clipboard.  according to + in vim
    PRMARY SELECTION works on last heightlight, pasted with middle mouse.
    according to * in vim.
    SECONDARY SELECTION was never used by me.
  You need some tool such xsel to connect tty and xwindow selection. :
    echo balabala  | xsel -i   # set primary selection to balabala
  If you are using neovim, you should install one of of this kind of tool.

  there has no clipboard in tty, but you can do it via x window xlipboard. 
    echo whatever | DISPLAY=:0 xsel -i
    DISPLAY=:0 xsel -o

-----------
2018.02.01:

linux:
  swap works likes virtual memory on windows.

  device:
    a device file or special file is an interface for a device driver that
    appears in a file system as if it were an ordinary file. They allow software
    to interact with a device driver using standard input/output system calls,
    which simplifies many tasks and unifies user-space I/O mechanisms.

  There are two general kinds of device files in Unix-like operating systems:
    character devices(not used in linux):
      provide unbuffered, direct access to the hardware device.

    block device:
      provide buffered access to hardware devices, and provide some abstraction
      from their specifics. Unlike character devices, block devices will always
      allow the programmer to read or write a block of any size (including
      single characters/bytes) and any alignment. 

  Pseudo-devices: 
    Device nodes on Unix-like systems do not necessarily have to correspond to
    physical devices. Nodes that lack this correspondence form the group of
    pseudo-devices.

  Some of the most commonly used (character-based) pseudo-devices include:
    /dev/null ‚Äì accepts and discards all input; produces no output (always
                returns an end-of-file indication on a read)
    /dev/zero ‚Äì accepts and discards all input; produces a continuous stream of
                NUL (zero value) bytes
    /dev/full ‚Äì produces a continuous stream of NUL (zero value) bytes when
                read, and returns a "disk full" message when written to
    /dev/random and /dev/urandom ‚Äì they produce a variable-length stream of
                                   pseudo-random numbers.

  In Unix-like operating systems, a loop device, vnd (vnode disk), or lofi (loop
  file interface) is a pseudo-device that makes a file accessible as a block
  device. such as:
    mount -o loop /media/balabala /dsfsdf/sdf.iso

  linux style file system:
    inode:
      inode is a data structure in a Unix-style file system that describes a
      filesystem object such as a file or a directory. Each inode stores the
      attributes and disk block location(s) of the object's data.Filesystem object
      attributes may include metadata (times of last change, access,
      modification), as well as owner and permission data.
      Every file has one inode.

    block:
      real file content, a file may take multiple blocks.

    directory:
      directy block stores child inode and their name(just like hard link),
      which means if you want to add/delete/rename a file in a directory, you
      need w privilege.

    link:
      hard link:
        simply add a new inode name pair in directory data block, no new inode
        created. You can only create hard link in the same filesystem. You can
        not create hard link for directory. 
      symbolic link:
        Add a new file, it's datablock is the target. It's a new file, it has
        it's own inode an datablock.

    number of hard links:
      a file has 1 hard link when it's created, it's stored in it's parent
      directory, it increases every time you create a hardlink for it. 

      a directory has 2 had link when it's created, one in it's parent
      directory, one in special entry '.', whose inode is the directory it self.
      it also increases everytime you create a child directory in it, as special
      entry '..' of child directory will point to it's parent, 

-----------
2018.02.02:
  linux:
    top:
      operation:
        o COMMAND=lantern   # filter command
        L                   # locate 
        k                   # kill
      top -n 1              # execute once and exit
      top -o %MEM           # sort by %MEM
    top detail is hard to remember, htop is much more user friendly.

    bash arithmetic works on integer only. you need bc to work on float:
      echo "scale=3; 1/100"|bc

  schedule commands:
    scheduled commands is done via cron deamon on linux.
    you can use crontab -e to schedule your commands. Or you can add commands to
    /etc/cron.daily/ to execute command in preset schedule.

  find default port for service:
    cat /etc/services

Multiples of bytes:
  Decimal    |           | Binary     |          |
  Value      | Metric    | Value      | IEC      | JEDEC
  1000^1	kB | kilobyte  | 1024^1	KiB | kibibyte | KB	kilobyte
  1000^2	MB | megabyte  | 1024^2	MiB | mebibyte | MB	megabyte
  1000^3	GB | gigabyte  | 1024^3	GiB | gibibyte | GB	gigabyte
  1000^4	TB | terabyte  | 1024^4	TiB | tebibyte | ‚Äì
  1000^5	PB | petabyte  | 1024^5	PiB | pebibyte | ‚Äì
  1000^6	EB | exabyte   | 1024^6	EiB | exbibyte | ‚Äì
  1000^7	ZB | zettabyte | 1024^7	ZiB | zebibyte | ‚Äì
  1000^8	YB | yottabyte | 1024^8	YiB | yobibyte | ‚Äì

-----------
2018.02.03:
linux:
  you can use xinput to control touchboard:
    xinput list
    xinput --disable touchboardid
  
c++:
  always always initialize class member.

gl:
  if you change marcro that will change uniform size(such as light_count), you
  need to rebind all uniform locations.

-----------
2018.02.04:

vim:
  aw includes trailing  or leading(if it has not trailing ) white space. Be
  careful with this, it might cause problem.
  c-w_c-o close all windows except current one. just like :only

-----------
2018.02.06:

linux:
  use who to check logged users.
  

-----------
2018.02.07:

vim:
  :25   goto line 25
  :/pattern/ goto line match pattern, different from :normal! /pattern
  ycm search .ycm_extra_conf vim dir of current file untile root, be careful
  about this.

linux:
  change tty font:
    sudo dpkg-reconfigure console-setup

-----------
2018.02.09:

linux:
  The splash screen is the picture that you can see while Linux is booting.

  The framebuffer (fbdev) is a character device providing access to graphics
  hardware. 

  Although the Linux frame-buffer supports 256 (or more) colors, the Linux console
  driver does not; therefore, console applications are still limited to 16 colors
  on the Linux console, frame-buffer or not.

  change tty resolution:
    type vbeinfo or videoinfo in grub prompt to get supported resolution.(or use
    hwinfo --framebuffer)
    add following lines to /etc/default/grub
      GRUB_GFXMODE=1920x1080x32
      GRUB_GFXPAYLOAD_LINUX=keep

  always use max tty resolution:
      GRUB_GFXMODE=auto

  change tty text color:
    echo -en "\e]P0222222"
    # e]p is the "set color escape", color format is XRRGGBB

  get max color in current terminal:
    tput colors   # only 8 for tty, 256 for gnome terminal


-----------
2018.02.10:

c++:
  Internal linkage refers to everything only in scope of a translation unit.

  External linkage refers to things that exist beyond a particular translation
  unit. In other words, accessible through the whole program, which is the
  combination of all translation units.

-----------
2018.02.12:

c++:
  After a serious of yaw and pitch, your camera will be tilted.  You need to get
  current eye position and use look at to fix up. or.

math:
  inertial space:
    rotation only coordinate transform. 
    a_p1 = R * a;
    a_p2 = T * a_p1;

  sometimes it's necessary to do translate before rotation:
    a_p1 = T * a;   // can i call p1 space initrial_t space ?
    a_p2 = T * a_p1;

  create model view matrix with negative eye translation in world space:
    it's trivial to create model view by translation * rotation:
      mv_mat = translate(world_pos) * rotate(world rotation)
    if your world rotation changed, but you want to reserve your eye position:
      // it should be understood as intrinsic transform.
      mv_mat = rotate(new world rotation) * translate(-eye)

  rotate around y+:
    | c  0 s |
    | 0  1 0 |
    | -s 0 c |

  post translate:
    | A00   a01 | * | I t01 | = | .. A00*t01+a01    | =  A +   | 0 A00*t01   |
    | a10_t Œ±11 |   | 0 1   |   | .. a10_t*t01+Œ±11  |          | 0 a10_t*t01 |

    |  A00  | * t01 =  a0 * œÑ0 + a1 * œÑ1 + a2 * œÑ2
    | a10_t |
    
    ‚à¥  A * T  =  | a0 a1 a2 a3+a0*œÑ0+a1*œÑ1+a2*œÑ2 |

  pre translate
    | I t01 | * | A00   a01 | = | A00+t01*a10_t a01+t01*Œ±11 | 
    | 0 1   | * | a10_t Œ±11 |   | ..                        | 
                              = A + | t01*a10_t t01*Œ±11 | = A + | œÑ0*Œ±30 œÑ0*Œ±31 œÑ0*Œ±32 œÑ0*Œ±11|
                                    | 0         0       |       | œÑ1*Œ±30 œÑ1*Œ±31 œÑ1*Œ±32 œÑ1*Œ±11|
                                                                | œÑ2*Œ±30 œÑ2*Œ±31 œÑ2*Œ±32 œÑ2*Œ±11|
                                                                | 0      0      0      0     |

-----------
2018.02.16:

math:
  dot distribution:
    x_t¬∑(y+z) = x_t¬∑y + x_t¬∑z
    (y+z)_t¬∑x = y_t¬∑x + z_t¬∑x
    (x+y)_t¬∑(x+y) = x_t¬∑x + 2x_t¬∑y + y_t¬∑y

  laff matrix vector scalar greek alphabet:
    Matrix | vector | scalor | code    | note
    A      | a      | Œ±      | code    | note
    B      | b      | Œ≤      | alpha   |
    C      | c      | Œ≥      | beta    |
    D      | d      | Œ¥      | gamma   |
    E      | e      | Œµ      | epsilon | ei is the ith unit basis vector
    F      | f      | œÜ      | phi     |
    G      | g      | Œæ      | xi      |
    H      | h      | ŒΩ      | eta     |
    I      |        |        |         | identity matrix
    K      | k      | Œ∫      | kappa   |
    L      | l      | Œª      | lambda  |
    M      | m      | Œº      | mu      | m(¬∑) = row dimension
    N      | n      | ŒΩ      | nu      | ŒΩ is shared with V. n(¬∑) = column dimension
    O      |        |        |         | not used
    P      | p      | œÄ      | pi      |
    Q      | q      | Œ∏      | theta   |
    R      | r      | œÅ      | rho     |
    S      | s      | œÉ      | sigma   |
    T      | t      | œÑ      | tao     |
    U      | u      | œÖ      | upsilon |
    V      | v      | ŒΩ      | nu      | ŒΩ is shared with N
    W      | w      | œâ      | omega   |
    X      | x      | œá      | chi     |
    Y      | y      | œà      | psi     |
    Z      | z      | Œ∂      | zeta    |

  if you partition matrix by rows, use a_h_t(transpose a with hat) to represent it.

  given x‚àà R_n, 
    x = Œ£(i, 0, n-1, xi*ei)

  let L:R_n --> R_m be a linear transformation, given x‚àà R_n, the result of y =
  L(x) is a vector in R_m, but then:
    y = L(x) = L(Œ£(i, 0, n-1, œái*ei)) 
             = Œ£(i, 0, n-1, L(œái*ei)) 
             = Œ£(i, 0, n-1, œái*L(ei))
             = Œ£(i, 0, n-1, œái*ai)  // let L(ei) = ai
             = Ax   // let A = | a0 a1 a2 .. am_1 |  //m_1 is m-1
    ‚à¥ so any L(x) can be represented as A(x), ai = L(ei)
  
  ‚àµ A(Œ±x) = Œ±Ax, A(x+y) = Ax+Ay
  ‚à¥ A is linear

  ‚à¥ A function f : R_n ‚Üí R_m is a linear transformation iff it can be written as
    a matrix-vector multiplication.

-----------
2018.02.18:

linux:
  install dict:
    sudo add-apt-repository universe
    sudo apt install dict     # cli client to dictd server
    sudo apt install dictd    # server
    sudo apt install dict-gcide dict-wn dict-devil dict-moby-thesaurus  # database
    
-----------
2018.02.19:

c++:
  if your class is derived from template class, such as A<int>, and there is a
  method called foo() in A<int>, you can not access foo directly in your derived
  class, "foo" in derived class is a nondependent name, which mean compiler
  won't search it in A<int>, there are 3 ways to access foo:
    1. this->foo(). Since this is always implicitly dependent in a template,
       this->foo is dependent and the lookup is therefore deferred until the
       template is actually instantiated, at which point all base classes are
       considered
    2. A<int>::foo to access.
    3. call using A<int>::foo prior to foo();

-----------
2018.02.20:

vim:
  you can not execute ex command in normal!:
    :normal! vi}:d     " won't work
  
  you can do it like this:
    :normal! vi}
    :'<,'>d

math:
  matrix-matrix multiplication distributive:
    A(B+C) = AB + AC
    (B+C)A = BA + CA

  let A‚àà R_mxn, let D denote a diagonal matrix:
    AD = |a0 a1 a2 ... an_1| D
       = |Œ¥0*a0 Œ¥1*a1 Œ¥2*a2 ... Œ¥n_1*an_1|

    (DA) = | Œ¥0*a0_h_t     |
           | Œ¥1*a1_h_t     |
           |  ...          |
           | Œ¥n_1*an_1_h_t |

  if A, B ‚àà R_n_n, and are both upper triangular matrix, then AB is also upper
  triangular matrix:
    C=AB
    assume i > j
      Œ≥ij = a_h_i_t¬∑bj
          = Œ£(k, 0, n-1, Œ±ik*Œ≤kn_1 )
        ‚àµ A is upper triangular, 
        ‚à¥ Œ±ik = 0 if k < i
    ‚à¥ Œ≥ij = Œ£(k, i, n-1, Œ±ik*Œ≤kn_1 )
        ‚àµ B is upper triangular, 
        ‚àµ k >= i > j
        ‚à¥ Œ≤kj = 0
    ‚à¥ Œ≥ij = 0

  if A, B ‚àà R_n_n, and are both lower triangular matrix, then AB is also lower
  triangular matrix:

  if B = AA_t B is symmetric
    Œ≤ij = a_h_i_t¬∑a_h_j = a_h_j_t¬∑a_h_i = Œ≤ji
  if B = A_tA B is symmetric
    Œ≤ij = ai_t¬∑aj = aj_t¬∑ai = Œ≤ji

  rank1 update:
    A = A + Œ±xx_t

-----------
2018.02.21:

math:
  gaussian transform. L_j
    I 0        0 0 ... 0
    0 1        0 0 ... 0   // the jth row
    0 -Œª_j+1,j 1 0 ... 0
    0 -Œª_j+2,j 0 1 ... 0
    0 .        . . .   0
    0 .        . .  .  0
    0 .        . .   . 0
    0 -Œª_m-1,j 0 0 ... 1

  L_j*A equals A except for i > j, (L_j*A)_h_i_t = a_h_i_t - a_h_j_t * Œª_i,j

  use LU factorization to solve Ax = b :
    L is unit lower trianglular matrix, U is upper trianglular matrix.
    A = LU, U = L_inv*A, L_inv will the the final gaussian transform matrix
    use gaussian transform to generate L and U col by col(current L col is the same as
    negative col in gaussian transform). so 
      L = L_n-1¬∑¬∑¬∑L_2*L_1*L_0

    forward substitution:
      solve Lz = b.  (z = apply gaussian transform to the right hand side)
      z = L_inv * b (the algorithm is nearly the same as LU factoriazation,
                    except b is an vector)

    backward substitution:
      solve Ux = z

windows:
  powershell:
     create a new ‚ÄúCurrent user, Windows PowerShell ISE‚Äù profile:
       if (!(Test-Path -Path $PROFILE ))
       { New-Item -Type File -Path $PROFILE -Force }

-----------
2018.02.22:

math:
  If Gaussian elimination with row exchanges (LU factorization with pivoting)
  completes with an upper triangular system that has no zero diagonal
  coefficients, then for all right-hand side vectors, b, the linear system Ax =
  b has a unique solution, x.

  permutation vector:
    k_j ‚àà {0,1..,n-1}, for 0<=j<=n-1.   k_i=k_j ==> i = j
    p = (k_0, k_1, ...k_n-1)_t 

  permutation matrix:
    P = P(p) = | e_k_0_t   |
               | e_k_1_t   |
                    .
                    .
                    .
               | e_k_n-1_t |

    P is the identity matrix with its rows(or cols) rearranged as indicated by
    the permutation vector (k 0 , k 1 , . . . , k n‚àí1 ).

  pivot matrix:
    P(j) is a pivot matrix, it's result of swap 0 and jth row of I.

  if in ith step of gaussian elimination, the ith item of current row is 0, you
  can not do gaussian elimination, you must swap row, that's what pivot matrix
  used for:
    PA = LU
    PAx = Pb
    LUx = Pb
    Lz = Pb
    Ux = z

  gaussian elimation will fail if no row can be found that puts a nonzero on the
  diagonal(except the last one, if the appended one is also zero).

  if A is invertible:
   ‚Ä¢ A is nonsingular.
   ‚Ä¢ A_inv exists.
   ‚Ä¢ AA_inv = A_inv*A = I.
   ‚Ä¢ A represents a linear transformation that is a bijection.
   ‚Ä¢ Ax = b has a unique solution for all b ‚àà R_n .
   ‚Ä¢ Ax = 0 implies that x = 0.
   ‚Ä¢ Ax = ej has a solution for all j ‚àà {0, . . . , n ‚àí 1}.
   ‚Ä¢ The determinant of A is nonzero: det(A) != 0.
   ‚Ä¢ LU with partial pivot doesn't break down.
   ‚Ä¢ C(A) = R_n.  // ==> m=n ==> a0¬∑¬∑¬∑an-1 is independent
   ‚Ä¢ A has linearly independent columns
   ‚Ä¢ N(A) = {0}.
   ‚Ä¢ rank(A) = n.

  inverse of special matrix:
    A = | 0 1 | A_inv = | 0 1 |
        | 1 0 |         | 1 0 |

    | Œ±_0,0 Œ±_0,1 |      | Œ±_1,1 -Œ±_0,1 |   
    | Œ±_1,0 Œ±_1,1 |_inv =| -Œ±_1,0 Œ±_0,0 |* (Œ±_0,0*Œ±_1,1 ‚àí Œ±_1,0*Œ±_0,1)

    | L_00   0    |        | L_00_inv               0      |
    | l_10_t Œª_11 |_inv =  | -l_10_t*L_oo_inv/Œª_11  1/Œª_11 |
    so if lower triangular matrix has no 0 on it's diagnal, it's invertible.

    | U_00   u_01 |        | U_00_inv  -U_00_inv*u_01/œÖ_11 |
    | 0      œÖ11  |_inv =  | 0         1/œÖ_11              |
    so if upper triangular matrix has no 0 on it's diagnal, it's invertible.

    | I 0    0 |        | I  0    0 |
    | 0 1    0 |        | 0  1    0 |
    | 0 l_21 0 |_inv =  | 0 -l_21 0 |

  A_t_i = A_i_t
    AA_i = I
    A_i_t * A_t = I
    A_t_i = A_i_t

c++:
  Special Members:
                          compiler implicitly declare
  | user dec  | def ctor  | dtor     | copy ctor | =        | move ctor | move =   |
  ----------------------------------------------------------------------------------
  | nothing   | defaulted | defauted | defauted  | defauted | defauted  | defauted |
  | any ctor  | not dec   | defauted | defauted  | defauted | defauted  | defauted |
  | def ctor  | user dec  | defauted | defauted  | defauted | defauted  | defauted |
  | dtor      | defaulted | user dec | defauted  | defauted | not dec   | not dec  |
  | copy ctor | not dec   | defauted | user dec  | defauted | not dec   | not dec  |
  | copy =    | defaulted | defauted | defauted  | user dec | not dec   | not dec  |
  | move ctor | not dec   | defauted | deleted   | deleted  | user dec  | not dec  |
  | move =    | defaulted | defauted | deleted   | deleted  | not dec   | user dec |

  in short, if you declare one of dtor, copt ctor, copy = , move ctor, move =,
  compiler will stop generating copy ctor, =, move ctor, move =

  Unnamed namespace is superior to static keyword, primarily because the keyword
  static applies only to the variables declarations and functions, not to the
  user-defined types.

-----------
2018.02.23:

math:
  gauss-jordan elimination:
    AX = B
    transform A to I

  Matrix A is said to be symmetric positive definite (SPD) if
    ‚Ä¢ A is symmetric; and
    ‚Ä¢ x_T*Ax > 0 for all nonzero vectors x ‚àà R_n.

  Cholesky factorization theorem:
    Let A ‚àà R_n√ón be a symmetric positive definite matrix. Then there exists a
    lower triangular matrix L ‚àà R_n√ón such that A = LL_T . If the diagonal
    elements of L are chosen to be positive, this factorization is unique.

-----------
2018.02.24:

math:

  row echelon form :  
                        | Œ±00 Œ±01 Œ±02 ¬∑¬∑¬∑ | 
                        | 0   Œ±11 Œ±12 ¬∑¬∑¬∑ | 
                        | 0   0   Œ±22 ¬∑¬∑¬∑ | 
                        | 0   0   0   ¬∑¬∑¬∑ | 

  reduced-echelon form :
                         | 1 0 0 ¬∑¬∑¬∑ |
                         | 0 1 0 ¬∑¬∑¬∑ |
                         | 0 0 1 ¬∑¬∑¬∑ |
                         | 0 0 0 ¬∑¬∑¬∑ |

  pivot : number in diagonal

  number of solutions of Ax=b:
    use gauss (jordan) elimination to transform |A b|:
      if there exists 0 = Œ≤ != 0,  it has no solution
      if no pivot is 0, it has one solution.
      if some pivots is 0, it has infinite solution.

    to solve Ax=b with infinite solution:
      use gauss (jordan) elimination to transform |A b|
      find a specific solution x_s by settiong free variable to 0
      find a non-trivial solution x_n to Ax=0 by setting free variable vector to
      unit base vector one by one
      the general solution will be x_s + Œ≤0x_n0 + Œ≤1x_n1 + ¬∑¬∑¬∑
      
  a vector space is a subset, S, of R_n with the following properties:
    ‚Ä¢ 0 ‚àà S (the zero vector of size n is in the set S)
    ‚Ä¢ If v, w ‚àà S then (v + w) ‚àà S
    ‚Ä¢ If Œ± ‚àà R and v ‚àà S then Œ±v ‚àà S
  S is closed under addition and scalar multiplication.

  vector space of R_n is also called subsapce of R_n

  Let A ‚àà R_m√ón . Then the column space of A equals the set
  { Ax | x ‚àà R_n } . It is denoted by C(A), it's a subspace of R_m

  Let A ‚àà R_m√ón . Then the row space of A equals the set
  { A_tx | x‚àà R_n } . It is denoted by R(A), it's a subspace of R_n

  Let A ‚àà R_m√ón , x ‚àà R_n , and b ‚àà R_m. Then Ax = b has a solution if and only if b ‚àà C(A).

  Let A ‚àà R_m√ón . Then the set of all vectors x ‚àà R_n that have the property
  that Ax = 0 is called the null space of A and is denoted by N(A) = {x|Ax = 0}.

  Let {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ  R_m . Then the span of these vectors, Span{v 0
  , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 }, is said to be the set of all vectors that are a linear
  combination of the given set of vectors, which is a subspace of R_m.

  If V = |v0 v1 ¬∑¬∑¬∑ vn‚àí1|, then Span(v0,v1 , . . . , vn‚àí1 ) = C(V).

  A spanning set of a subspace S is a set of vectors {v0 , v1 , . . . , vn‚àí1 }
  such that Span({v0 , v1 , . . . , vn‚àí1 }) = S.

  Let {v0 , . . . , vn‚àí1 } ‚äÇ R_m. Then this set of vectors is said to be
  linearly independent if œá0v0 + œá1v1 + ¬∑ ¬∑ ¬∑ + œán‚àí1vn‚àí1 = 0 implies that œá0
  = ¬∑ ¬∑ ¬∑ = œán‚àí1 = 0. A set of vectors that is not linearly independent is said
  to be linearly dependent.

  if a set of vector is said to be linearly independent, none of these vector
  can be written as linear combination of the other vectors.

  Let {a0 , . . . , an‚àí1 } ‚äÇ R_m and let A = | a0 ¬∑¬∑¬∑ an‚àí1 |. Then the vectors
  {a0 , . . . , an‚àí1 } are linearly independent if and only if N(A) = {0}.

  Let {a0 , a1 , . . . , an‚àí1 } ‚àà R_m and n > m. Then these vectors are linearly
  dependent.

  Let S be a subspace of R_m . Then the set {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ R_m is
  said to be a basis for S if:
    {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } are linearly independent 
    Span{v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } = S.

  Let S ‚äÇ R_m . Then S contains at most m linearly independent vectors.

  Let S be a nontrivial subspace of R m . (In other words, S != {0}.) Then
  there exists a basis {v0 , v1 , . . . , vn‚àí1 } ‚äÇ R_m such that Span(v0 , v1 ,
  . . . , vn‚àí1 ) = S.

  Let S be a subspace of R_m and let {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ R_m and {w0 ,
  w1 , ¬∑ ¬∑ ¬∑ , wk‚àí1 } ‚äÇ R_m both be bases for S.  Then k = n. In other words,
  the number of vectors in a basis is unique.

  The dimension of a subspace S equals the number of vectors in a basis for that
  subspace.

  Let A ‚àà R_m√ón . The rank of A equals the number of vectors in a basis for the
  column space of A. We will let rank(A) denote that rank.

  Let {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ R_m be a spanning set for subspace S and
  assume that vi equals a linear combination of the other vectors. Then {v0 , v1
  , ¬∑ ¬∑ ¬∑ , vi‚àí1 , vi+1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } is a spanning set of S.

  Let {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ R_m be linearly independent and assume that
  {v0 , v1 , ¬∑ ¬∑ ¬∑ , vn‚àí1 } ‚äÇ S where S is a subspace. Then this set of vectors
  is either a spanning set for S or there exists w ‚àà S such that {v0 , v1 , ¬∑ ¬∑
  ¬∑ , vn‚àí1 , w} are linearly independent.

linux:
  man hier  # filesystem hierarchy

-----------
2018.02.25:

math:

1inch = 2.54cm
1foot = 12 inch = 30.48cm
9.68m = 31.75853feet ‚âà 32feet
1yard = 3feet = 91.44cm
1mile = 5280feet = 1609.344m
1 league = 4,828.0417 meter (distance a man can cover in 1 hour)

1pound = 0.45359237kg


-----------
2018.02.26:

math:

‰ªª‰∏ÄÊéíÂàó‰∏≠Ôºå ÂΩìÊüê‰∏§‰∏™ÂÖÉÁ¥†ÁöÑÂÖàÂêéÊ¨°Â∫è‰∏éÊ†áÂáÜÊ¨°Â∫è‰∏çÂêåÊó∂Ôºå Â∞±ËØ¥Êúâ1‰∏™ÈÄÜÂ∫è.
‰∏Ä‰∏™ÊéíÂàó‰∏≠ÊâÄÊúâ‰Ω†ËôöÁöÑÊÄªÊï∞Âè´Ëøô‰∏™ÊéíÂàóÁöÑÈÄÜÂ∫èÊï∞„ÄÇ
ÈÄÜÂ∫èÊï∞‰∏∫Â•áÊï∞ÁöÑÊéíÂàóÂè´ÂÅöÂ•áÊéíÂàóÔºåÂÅ∂Êï∞ÁöÑÂè´ÂÅöÂÅ∂ÊéíÂàó„ÄÇ

det(A) = Œ£(-1)^t(Œ±_0,p0*Œ±_1,p1*¬∑¬∑¬∑Œ±_n-1,p_n-1) 
det(A) = Œ£(-1)^t(Œ±_p0,0*Œ±_p1,1*¬∑¬∑¬∑Œ±_pn-1,n-1) 
(there are n! different permutations, t is number of inversions)

if D is a diagonal matrix:
  det(D) = Œ¥_0,0 * Œ¥_1,1 * ¬∑¬∑¬∑ Œ¥_n-1,n-1

if D is reverse diagonal matrix
  det(D) =(-1)^(n*(n-1)/2)*Œ¥_0,0 * Œ¥_1,1 * ¬∑¬∑¬∑ Œ¥_n-1,n-1

if U is upper triangular matrix:
  det(U) = œÖ_0,0 * œÖ_1,1 * ¬∑¬∑¬∑ œÖ_n-1,n-1

ÂØπÊç¢: Âú®ÊéíÂàó‰∏≠Ôºå Â∞Ü‰ªªÊÑè‰∏§‰∏™ÂÖÉÁ¥†ÂØπÊéâÔºå ÂÖ∂‰ΩôÂÖÉÁ¥†‰∏çÂä®
Áõ∏ÈÇªÂØπÊç¢: Â∞ÜÁõ∏ÈÇª‰∏§ÂÖÉÁ¥†ÂØπÊç¢„ÄÇ

1‰∏™ÊéíÂàó‰∏≠ÁöÑ‰ªªÊÑè‰∏§‰∏™ÂÖÉÁ¥†ÂØπÊç¢ÔºåÊéíÂàóÊîπÂèòÂ•áÂÅ∂ÊÄß„ÄÇ

det(A) = det(A_t)
det(A) = -1 * det(swap i, j row(col) of A)
det(A) = 0 if a_i = k*a_j, i != j
if B = A, b_i = k*a_i, det(B) = k*det(A)
if a_i = b_i + c_i
det(A) = det(|a0 a1 ... b_i ... an-1|) + det(|a0 a1 ... c_i ... an-1|)

A = | A_00   0    |,  det(A) = det(A_00) * det(A_11)
    | A_10   A_11 |

minor m_ij = det(delete ith row, jth col of A)
cofactor c_ij = (-1)^(i+j)(m_ij)

det(A) = a_i,0*det(c_i,0) + a_i,1*det(c_i,1) + ...a_i,n-1*det(c_i,n-1)

vandermonde:
  A = 
      | 1         1         ... 1           |
      | x_0       x_1       ... x_n-1       |
      | x_0^2     x_1^2     ... x_n-1^2     |
      | ...       ...       ... ...         |
      | ...       ...       ... ...         |
      | x_0^(n-1) x_1^(n-1) ... x_n-1^(n-1) |

  det(A) = Œ†_n>i>j>=0(x_i - x_j)

a_i,0*det(A_c_j,0) + a_i,1*det(A_c_j,1) + ...a_i,n-1*det(A_c_j,n-1) = 0 if i != j

law of cramer:
  if det(A) != 0, Ax=b has unique solution, x_i = det( a_i = b)  / det(A)

if Ax = b has 0 or more than 1 solutions, det(A) = 0

-----------
2018.02.27:

vim:
  visual-block replace will replace every screen char with the same char.
  use \%V to match inside the gv area. 
    assume you visual area is "foo bar"
      /\%Vfoo.*bar  will match "foo bar"
      /\%Vfoo.*bar\%V will match "foo ba", no "r"
      /\%Vfoo.*ba\%Vr will match "foo bar"

  
math:
  det(ŒªA) = Œª^n*det(A)
  det(AB) = det(A) * det(B)
    det( | A  0 | ) = det(A) * det(B)  // assume A B are both nxn squre matrix
         | -I B |
                    = det( | A  AB | ) // c1 + c1 * B
                           | -I 0  |
                    = (-1) ^n * det ( | -I 0   | ) // swap rows n times
                                      | A  AB  |
                    = (-1)^n * det(-I) * det(AB)
                    = (-1)^n * (-1)^n * det(AB)
                    = det(AB)
  det(AB) = det(BA) = det(A)* det(B)

  let A be nxn square matrix, it's adjugate matrix is:
    A_a = | c_0,0   c_1,0   ...   C_n-1,0   |
        = | c_0,1   c_1,1   ...   C_n-1,1   |
        = | ...     ...     ...   ...       |
        = | ...     ...     ...   ...       |
        = | c_0,n-1 c_1,n-1 ...   C_n-1,n-1 |

    A*A_a = A_a*A = det(A) I
    A_i = A_a / det(A)

  let A = PLP_i
      A^2 = PL^2P_i
      A^n = PL^nP_i

  A_t*A = 0 iff A = 0
    
-----------
2018.02.28:

math:
  basic matrix row transform:
   E(i,j)   a_t_i <-> a_t_j, 
   E(i(k))  a_t_i = k * a_t_i
   E(ij(k)) a_t_i += k * a_t_j

   E(i,j)_i = E(i,j)
   E(i(k))_i = E(i(k))/k
   E(ij(k))_i = E(ij(-k))

  if A after finite basic trasform become B, A„ÄúB
  A„ÄúB ==> B„ÄúA
  A„ÄúB && B„ÄúC ==> A„ÄúC
  Any matrix A can be transformed into standard form via basic transform:  
    | I 0 |
    | 0 0 |, rank(A) = dimension of I

  A~r~B iff PA = B, P is nonsingular
  A_i exists iff A~r~I
  A~c~B iff AQ = B, Q is nonsingular
  A„ÄúB iff PAQ = B, P,Q is non singular

  let A be a square matrix, A_i exists iff A = P1P2...., Pi is bais matrix

  let A be a mxn matrix, pick k rows and columns(k<=m && k<=n), the crossing k^2
  elements elements will form a k order determinent, Áß∞‰ΩúAÁöÑkÈò∂Â≠êÂºè.

  ËÆæÂú®A‰∏≠Êúâ‰∏Ä‰∏™‰∏ç‰∏∫0ÁöÑrÈò∂Â≠êÂºèDÔºå ‰∏îÊâÄÊúâr+1Èò∂Â≠êÂºè(Â≠òÂú®ÁöÑËØù)ÂÖ®‰∏∫0,
  ÈÇ£‰πàDÁß∞‰∏∫AÁöÑÊúÄÈ´òÈò∂Èùû0Â≠êÂºèÔºå r = rank(A) or R(A), 0Áü©ÈòµÁöÑÁß©‰∏∫0

  0<=R(A)<=min(m,n)
  R(A) = R(A^t)
  if A is n squre, R(A) = n iff det(A) != 0
  if A„ÄúB , then R(A) = R(B)
  if P,Q is nonsingular, R(PAQ) = R(A)
  max(R(A), R(B)) <= R(A,B) <= R(A) + R(B)
  R(A+B)<=R(A)+R(B)
  R(AB)<=min(R(A), R(B))
  if let A be mxn, B be nxl AB=0 then R(A) + R(B) <=n

  Ax=b, (b‚àà R_n) has 0 solusion if R(A) < R(A, b)
             1 solution if R(A) = R(A,b) = n
             n solution if R(A) = R(A,b) < n

  AX=B has solutions iff R(A) = R(A, B)

-----------
2018.03.01:

math:
  {x=(x0,x1....xn-1)_t | a0x0+a1x1+....an-1xn-1 = b }
  Âè´ÂÅönÂîØÂêëÈáèÁ©∫Èó¥R_n‰∏≠ÁöÑn-1ÂîØË∂ÖÂπ≥Èù¢

  if b1,b2,...bl are linear combination s of a1,a2,...am, R(|b1,b2...|) <=
  R(|a1,a2...|)

  Â¶ÇÊûú a0,a1...an-1 Âíå b0,b1,..bn-1 ËÉΩÁõ∏‰∫íÁ∫øÊÄßË°®Á§∫Ôºå Âàô‰∏§‰∏™ÂêëÈáèÁªÑÁ≠â‰ª∑

  a0,a1..an-1 is linearly dependent iff  R(|a0,a1..an-1|) < n; a0,a1...an-1 is linearly
  independent iff R(|a0,a1...an-1|) = n

  ÊúÄÂ§ßÊó†ÂÖ≥ÁªÑÊâÄÂåÖÂê´ÁöÑÂêëÈáè‰∏™Êï∞Áß∞‰∏∫ÂêëÈáèÁªÑÁöÑÁß©

  R(A) = R(a0,a1....an-1) = R(a_h_0, a_h_1, .....a_h_n-1)

  ËÆæmxnÁü©ÈòµAÁöÑÁß©R(A) = r, ÂàônÂÖÉÈΩêÊ¨°Á∫øÊÄßÊñπÁ®ãÁªÑAx=0ÁöÑËß£ÈõÜSÁöÑÁß©R(S) = n-r

  R(A_tA) = R(A)

-----------
2018.03.02:

math:
  Let V, W ‚äÇ R_n be subspaces. Then V and W are said to be orthogonal if and only
  if v ‚àà V and w ‚àà W implies that v_t*w = 0.

  Given subspace V ‚äÇ R_n , the set of all vectors in R_n that are orthogonal to
  V is denoted by V^‚ä• (pronounced as ‚ÄúV-perp‚Äù).

  Let A ‚àà R_m√ón . Then R(A)‚ä• N(A).

  Let A ‚àà R_m√ón . Then every x ‚àà R_n can be written as x = x_r + x_n where x_r ‚àà
  R(A) and x_n ‚àà N(A).

  ‚àµ Ax_r = Ax_r + 0 = A(x_r + x_n) = Ax
  ‚à¥ We conclude that if Ax = b has a solution, then there is a x_r ‚àà R(A) such
  that Ax_r = b.

  Let A ‚àà R m√ón . Then A is a one-to-one, onto mapping from R (A) to C ( A ).

  Given A ‚àà R_m√ón the left null space of A is the set of all vectors x such that
  x_t*A = 0, Clearly, the left null space of A equals the null space of A_T .

  Let A ‚àà R_m√ón . Then the left null space of A is orthogonal to the column
  space of A and the dimension of the left null space of A equals m ‚àí r, where r
  is the dimension of the column space of A.

  If A ‚àà R_m√ón(m need not equal to n) has linearly independent columns, then
  A_t*A is nonsingular (equivalently, has an inverse, A_t*A*xÃÇ = A_t*b has a
  solution for all b, etc.).

  Let A ‚àà R_m√ón, b ‚àà R_m , and x ‚àà R_n and assume that A has linearly
  independent columns. Then the solution that minimizes the length of the vector
  b ‚àí Ax is given by xÃÇ = (A_t*A)_i*A_t*b.

  if Ax=b has no solution, b !‚àà  C(A), assume z‚àà C(A) and b = z + w, inorder to
  minimize ‚Äñb-z‚Äñ, wo let w‚ä• z, which means w‚àà N(A_t) which means:
    A_t*w = 0
    A_t(b-z) = 0
    A_t*z = A_t*b
    A_t*A*xÃÇ = A_t*b
    xÃÇ = (A_t*A)_i*A_t*b

    z = AxÃÇ = A*(A_t*A)_i*A_t*b  //proj of b on C(A)

    The orthogonal projection of b onto C(A)‚ä• is given by 
      b ‚àí z = [I ‚àí A(A_t*A)_i*A_t]b.

  Let A ‚àà R_m√ón . If A has linearly independent columns, then A‚Ä† = (A_t*A)_i*A_t
  is called the (left) pseudo inverse. Note that this means m ‚â• n and A‚Ä†*A =
  (A_t*A)_i*A_t*A = I.

-----------
2018.03.03:

linux:
  get number of cores:   getconf _NPROCESSORS_ONLN
  make in multiple cores : make -j $(getconf _NPROCESSORS_ONLN)
  
-----------
2018.03.05:

math: 
  Let q0 , q1 , . . . , qk‚àí1 ‚àà R_m . Then these vectors are (mutually)
  orthonormal if for all 0 ‚â§ i, j < k :
    qi_t * qj = 1   if i == j
    qi_t * qj = 0   otherwise

  Let a0 , a1 , . . . , ak‚àí1 ‚àà R m be linearly independent vectors and let q0 ,
  q1 , . . . , qk‚àí1 ‚àà R m be the result of Gram- Schmidt orthogonalization.
  Then Span({a0 , a1 , . . . , ak‚àí1 }) = Span({q0 , q1 , . . . , qk‚àí1 }).

  A matrix Q ‚àà R_m√ón has mutually orthonormal columns if and only if Q_t*Q = I.
  A matrix Q ‚àà R_m√ón has mutually orthonormal rows if and only if Q*Q_t = I.

-----------
2018.03.06:

math:
  QR factorization:
    (a0 a1 ...an-1) = (q0 q1 ... qn-1) * | œÅ_0,0   œÅ_0,1   ... œÅ_0,n-1   |
                                         | 0       œÅ_1,1   ... œÅ_1,n-1   |
                                         | 0       ...     ... ...       |
                                         | 0       0       ... œÅ_n-1,n-1 |
    in k th column:
      for p = 0...k-1
        œÅ_p,k = qp_t * ak
      ak_‚ä•  = ak - Œ£_p_0_k-1(œÅ_p,k * q_p)
      œÅ_k,k = ‚Äñak_‚ä• ‚Äñ  
      q_k = ak_‚ä• /œÅ_k,k

  to solve Ax ‚âà b
    x = (A_t*A)_i*A_t *b
      = ((QR)_t * QR )_i * (QR)_t * b
      = (R_t*R)_i * R_t*Q_t*b
      = R_i*Q_t*b
    Rx = Q_t*b

google:
  http://www.being.org.cn/tool/google.htm#8.3
  multiple keyworkd :  a [+] b 
  exclude b :  a -b
  or :  a OR b
  sentence : "this is a sentence"
  search in specific site : a site:sina.com
  search filetype : a filetype:pdf
  search url with keyword : inurl:keyword_in_url a
  search title with keyword : intitle:keyword_in_title a
  search everything linked to specific web page : link:www.sina.com.cn

  image search support + - OR site and filetype

linux:
  select last field of cut:
    ag --nogroup -o '^[ \t]*namespace\s*\w+' --cpp | rev | cut -d ' ' -f 1 | rev | sort | uniq > namespaces

git:
  sync fock:
    git remote add upstream remote_address
    git fetch remote
    git checkout master
    git merge upstream/master
    git push

-----------
2018.03.07:

math:
  conpoment of b in direction of a:
    u = a_t*b*a/(a_t*a)

vim:
  syntax region is valid even end match does't exist
  syn region name start=/a/ skip=/c/ end=/b/ 

  you can manage continas in cluster which can be updated by other users
    syn cluster clusterName contains=...
    syn match xgroup ..... contains=@clusterName " fetch contains from cluster
    syn keyword new_item ...  " create new group
    syn cluster add=new_item contained  " newly create group can be contained in xgroup

----------
2018.03.08

math:
  if Ax = Œªx, scalars Œª that satisfy it for nonzero vector x are known as
  eigenvalues while the nonzero vectors is knows as eigenvectors. (Œª,x) is said
  to be an eigenpair.

  to solve this, rearrange it as (A-ŒªI)x = 0, A must be square, (A-ŒªI) must be
  singular. x‚àà N(A-ŒªI)

  the set of all vectors x that satisfy Ax = Œªx is a subspace. every vector in
  this subspace except 0 is an eigenvector.

  Eigenpairs for diagnal matrix are given by (Œ¥0,e0), (Œ¥1,e1), ¬∑ ¬∑ ¬∑ , (Œ¥n‚àí1, en‚àí1)

  The eigenvalues of upper or lower triangular matrix are Œ±0,0, Œ±1,1,...Œ±n-1,n-1

c++:
  if you really want to define your template class or template function in
  source file without include it in head file, you can do something like this in
  the end of source
  file:
    template class ClassName<SpecificType0>;
    template class ClassName<SpecificType1>;
    ...
    template class ClassName<SpecificTypen>;
    void define_template_function(){
      void func<SpecificType0();
      void func<SpecificType1();
      ...
      void func<SpecificType2();
    }
  it will cause compiler to compile these particular types, so the associated
  class member functions will be available at link time.

----------
2018.03.09

math:
  let A be nxn matrix, if X_iAX = Œõ, the matrix X is said to diagnalize matrix
  A. rank(X) = n.

  Matrices for which such a matrix X does not exists are called defective
  matrix.

  Given A ‚àà R_n√ón ,
  p_n (Œª) = det(A ‚àí ŒªI) = Œª^n + Œ≥_n‚àí1*Œª^n‚àí1 + ¬∑ ¬∑ ¬∑ + Œ≥_1*Œª + Œ≥_0 
  for some coefficients Œ≥_0, Œ≥_1 , . . . , Œ≥_n‚àí1 ‚àà R.

  The set of all roots of p_n(Œª), which is the set of all eigenvalues of A, is
  denoted by Œõ(A) and is called the spectrum of matrix A.

  Given A ‚àà R_n√ón , p_n(Œª) = det(A ‚àí ŒªI) is called the characteristic
  polynomial.

  The characteristic polynomial can be factored as 
  p_n(Œª) = det(A ‚àí ŒªI) = (Œª ‚àí Œª 0 )^n_0*(Œª ‚àí Œª_1)^n_1 ¬∑ ¬∑ ¬∑ (Œª ‚àí Œª_k‚àí1 )^n_k‚àí1 ,
  where n0 + n1 + ¬∑ ¬∑ ¬∑ + nk‚àí1 = n and nj is the root Œª j , which is known
  as the (algebraic) multiplicity of eigenvalue Œª_j .

c++:
  you don't need virtual destructor unless you will destroy derived class with
  base class pointer.

linux:
  xargs -I conflicits with -n ?
    types='BOOK BODY'
    # following command will not print BOOK BODY on seperate lines
    echo $types | xargs -I {} -n 1 bash -cx 'echo {}' 

  redirect each execution of xargs:
    ... | xargs -I {} bash -c ' ... > ..'


----------
2018.03.10

math:
  jordan block has eigenvalue Œª of algebraic multiplicity k, but geometric
  multiplicity one (it has only one linearly independent eigenvector).

    J_k(Œª) =  | Œª 1 0 ... 0 0 |
              | 0 Œª 1 ... 0 0 |
              | 0 0 Œª ... 0 0 |
              | ...       0 0 |
              | 0 0 0 ... Œª 1 |
              | 0 0 0 ... 0 Œª |
    Œõ(J) = {Œª}

  The geometric multiplicity of an eigenvalue Œª equals the number of linearly
  independent eigenvectors that are associated with Œª.

  Let A ‚àà R_n√ón and A_i,i are a square matrices. Then Œõ(A) = Œõ(A_0,0 ) ‚à™ Œõ(A_1,1
  ) ‚à™ ¬∑ ¬∑ ¬∑ ‚à™ Œõ(A_N‚àí1,N‚àí1 ).

  Let A ‚àà R_n√ón be symmetric, Œª_i != Œª_j , Ax_i = Œª_i*x_i and Ax_j = Œª_j*x_j
  then xi_t*x_j = 0

  Let A ‚àà R n√ón be symmetric. Then its eigenvalues are real valued.

  Let Ax = Œªx and k ‚â• 1. A^k*x = Œª^k*x

  A ‚àà R_n√ón is nonsingular if and only if 0 !‚àà  Œõ(A).

linux:
  use wc to count lines words or bytes

  use cmp compare files byte by byte

  use comm to cmpare files line by line (must be sorted)
    comm -23 file1 file2  # print uniq item in file1
    comm -13 file1 file2  # print uniq item in file2
    comm -12 file1 file2  # print common item in file1 and file2

  uniq -cd sorted  # find duplicated lines in a file

  read from file line by line:
    while IFS= read -r variable ; do
      ...
    done;<file
  
  proces substitution:
    comm -23 <(sort file0|uniq) <(sort file1|uniq)

----------
2018.03.11

c++:
  change data alignment:
    #pragma pack(push)
    #pragma pack(1)

    struct Data{
      ...
    }

    #pragma pack(pop)

linux:
  use xxd to dump hex or revert

----------
2018.03.12

linux:
  print hex
    echo $((16#ff))
    echo $((0xff))
  print oct
    echo $((8#77))
    echo $((077))

vim:
  count item:
    :%s/item//gn

----------
2018.03.14

vim:
  shift m lines 5 times
  :>>>>>m

qt:
  you can connect signal to another signal

  qt automatically removes all connections involving an object when the object
  is deleted. although you can manually do it with disconnect

  if a signal has more parameters than the slot it is connected to, the
  additional parameters are simply ignored.

  One of Qt's major achievements has been the extension of C++ with a mechanism
  for creating independent software components that can be bound together
  without any component knowing anything about the other components it is
  connected to.  The mechanism is called the meta-object system, and it provides
  two key services: signals≈îslots and introspection.

  meta-object system:
    The Q_OBJECT macro declares some introspection functions that must be
    implemented in every QObject subclass: metaObject(), tr(), qt_metacall(),
    and a few more.

    Qt's moc tool generates implementations for the functions declared by
    Q_OBJECT and for all the signals.

    QObject member functions such as connect() and disconnect() use the
    introspection functions to do their work.
  
----------
2018.03.15

vim:
  a and i is the same on blank line.

qt:
  After creating the user interface, setupUi() will automatically connect any
  slots that follow the naming convention on_objectName_signalName() to the
  corresponding objectName's signalName() signal

  Qt's parent≈îchild mechanism is implemented in QObject. When we create an
  object (a widget, validator, or any other kind) with a parent, the parent adds
  the object to the list of its children.  When the parent is deleted, it walks
  through its list of children and deletes each child. The children themselves
  then delete all of their children, and so on recursively until none remain.
  The parent-child mechanism greatly simplifies memory management, reducing the
  risk of memory leaks. The only objects we must call delete on are the objects
  we create with new and that have no parent.  And if we delete a child object
  before its parent, Qt will automatically remove that object from the parent's
  list of children.  
  
  For widgets, the parent has an additional meaning: Child widgets are shown
  within the parent's area. When we delete the parent widget, not only does the
  child vanish from memory, it also vanishes from the screen.

----------
2018.03.16

qt4:
  The parent-child relationship doesn't mean the same thing for dialogs as for
  other widgets. A dialog is always a window in its own right, but if it has a
  parent, it is centered on top of the parent by default. A child dialog also
  shares its parent's taskbar entry.

  A modeless window is one that runs independently of any other windows in the
  application.

  A modal window is a window that pops up when invoked and blocks the
  application, preventing any other processing or interactions from taking place
  until the window is closed.

  A dialog is modeless if it's invoked using show() (unless we call setModal()
  beforehand to make it modal); it is modal if it's invoked using exec().

----------
2018.03.17

qt4:
  The top-left pixel of a Qt widget is located at position (0, 0), and the
  bottom-right pixel is located at (width() - 1, height() - 1).

linux:
  print available locales:
    locale -a

----------
2018.03.20

qt4:
  draw a pixel at x,y with antialiasing, the pixel center is at x+0.5, y+0.5
  draw a pixel at x,y with antialiasing, following pixels will be colored grey:
    (x-1, y-1)
    (x-1, y)
    (x, y-1)
    (x, y)
    this is 4 pixels surrounding x,y

  there are two sets of coordinates in qt:
    logical coordinate:
      you specify your geometry in this coordinate
    physical coordinate:
      the real window coordinates

  boundary of logical coordinates, works similar like ortho projection in opengl:
    paint->window(x,y,width,height)
  
  viewport in qt works similar as viewport like opengl:
    paint->setViewport(x,y,with,height)

----------
2018.04.03

linux:
  use im-confg to swtich fcitx or ibus.
  sort -h can sort someting like house number nicely.

----------
2018.04.03

math:
  0C = 32F
  100C = 212F
  which means 1C change is equal to 1.8F change
  so to change from F to C:
    (x-32)/1.8
  to change from C to F
    x*1.8 + 32

----------
2018.04.07

linux:
  change login shell to zsh:
    chsh -s $(which zsh)

----------
2018.04.10

linux:
  you can use pushd, popd to use directory stack.
  dirs will print everythign in the directory stack.

----------
2018.04.13

linux:
  vim:
    use byzana-record to record gui animation.
    use ttyrec to record tty screen animation, then use ttygif to convert
    video record to gif.

----------
2018.04.26

qt4:
  editor widget created by item delegate in listwidget will be removed
  immediately if lose focus.

  setGeometry has no meaning in a layout.

  backgound color and property like that can be changed via stylesheet.

----------
2018.04.26

qt4:
  A dialog is always a top-level widget, which means you must specify global
  coordinates to position it. but if it has a parent, its default location is
  centered on top of the parent's top-level widget (if it is not top-level
  itself).

vim:
  viml string doesn't support negative index.

----------
2018.05.03

git:
  search deleted file:
    git log --all --full-history -- **/filename

----------
2018.05.05

vim:
  autoload function only exists when it's called, which means you can't test if
  an autoload functions exits like this:  exists(*plug#func)

linux:
  use ffempg to convert video format
  ffempt -i input.avi output.mp4

----------
2018.05.09

bash:
  expand variable twice:
    file=$(eval echo $file) # $file might be some variable

----------
2018.05.10

bash:
  Words of the form $'string' are treated specially. The word expands to
  "string", with backslash-escaped characters replaced as specified by the ANSI
  C standard. It is a ksh93 syntax also supported by bash, zsh, mksh and FreeBSD
  sh.

  always use array to store command line options with special characters.
    optoins="--id 'seyda neen'"
    et $options # this will generate erryr, 'seyda neen' will be split into
    'seyda and neen'

----------
2018.05.11
bash:
  compgen -W wordlist -- word 

  worldlists:
    worldlist will be treated as current typing words. single quote needs to be
    escaped, because worldlist treated it as starting quote around string:
      "a b'c d" will be split into "a"  "bc d" because bash think you might be typing "b'c d'"

    splited words will be expanded(just like echo splitedWord, no extra quote):
      x=y
      y=z
      compgen -W "\$$x"  # will generate z

    in bash "abc" can be typed in following ways(" works just like '):
      abc
      a''bc
      a'b'c
      a'bc'
      ab'c'

    which means following compgen will generate the same result
      compgen -W "abc" "a"
      compgen -W "abc" "a'"
      compgen -W "abc" "a'b"
      compgen -W "abc" "ab"
      compgen -W "abc" "ab'"

    if you have escaped ' in your splited word:
      compgen -W "a\'bc" "a'b" # generate nothing, impossible to continue 
                               # from a'b to generate a'bc (keep in mind, it
                               # needs to be expanded again)
      compgen -W "a\'bc" "a'"  # good to go, a''\'bc

    if you really want to complete "a'bcdef" from "a'b":
      compgen -W "a\'bcdef" "a\'b" # you must escape ' in both wordlist and
                                   # word!! in your script

    the same rule apply to \:
      assume you want to generate "a\\bcd" from "a\\b",
        a\b    -----> ab
        a\\b   -----> a\b
        a\\\\b -----> a\\b

      so you must replace \ with \\\\ in both wordlist and word. Again, keep in
      mind, splited wordlist and word need to be expand again, use the rule of
      echo word, no extra quotes.

    remember this: compgen complete possible typing !!! 

bash:
  word split:
    word splitting only happens when something expaned
    explicit null
      x='' # $x will be treated as empty string
    implicit null
      x=   # $x will be nothing 

----------
2018.05.13

vim:
  unamed regiser always point to the last used register.
    gv"sy
    let @s='whatever'  " @" is equal to whatever, not something you copied into
                       " s register in the 1st line.

c++:
  be very careful with std::function:
    std::function<const std::string&(const void*) > totally accepts
    [](const void*)->std::string
    this can cause local reference problem, total night mare.
  
