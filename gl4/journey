-----------
2018.01.13:

lighting of normalmap is prefered to be calculated in tangent space(so there has
no transform in fs shader), which means you have to transform light, camera into
tangent space in vertex shader. Local viewer must always be true(it can be
false only in view space)

Although it's easier to calculate normalmap lighting in view space, you only
need to transfrom normal from tbn space to view space in fragment shader, as
long as performance is not an issue.

-----------
2018.01.16:

freeimage:
  FreeImage uses a BGR[A] pixel layout under a Little Endian processor (Windows, Linux) and uses a
  RGB[A] pixel layout under a Big Endian  processor (Mac OS X or any Big Endian Linux / Unix). 

-----------
2018.01.18:

it's totally legal to bind the same buffer to different target.

-----------
2018.01.30:

normal achieved from normal texture still needs to be normalized:
// be very careful about this!!, not easay to debug, totally nightmare
vec3 t_normal = normalize(texture(normal_map, fi.texcoord).xyz * 2 - 1); 

-----------
2018.02.03:

gl:
  if you change marcro that will change uniform size(such as light_count), you
  need to rebind all uniform locations.

-----------
2018.02.12:

gl:
  After a serious of yaw and pitch, your camera will be tilted.  You need to get
  current eye position and use look at to fix up.

----------
2018.10.04

glsl:
  pow(x,y) only works for positive x

----------
2018.10.15

freeimage:
  some image use 8 bpp, but it might be color index.
  I should always convert image to 32bits before i use it in opengl.

-----------
2018.11.2

gl:
  The contents of the back buffer become undefined after a swap.

-----------
2018.11.5

opengl:
  a buffer texture is simply a way for the shader to directly access a large
  array of data, generally larger than uniform buffer objects allow.

-----------
2018.11.8

gl:
  you must use multisample texture if you want to enable multisample during rtt:
     glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);
     glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGBA8, width, height, false);
     glBindFramebuffer(GL_FRAMEBUFFER, fbo);
     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
     GL_TEXTURE_2D_MULTISAMPLE, tex, 0)

  you can sample multisample texture like this:
    uniform int texSamples;
    uniform sampler2DMS tex;

    vec4 textureMultisample(sampler2DMS sampler, ivec2 coord)
    {
        vec4 color = vec4(0.0);

        for (int i = 0; i < texSamples; i++)
            color += texelFetch(sampler, coord, i);

        color /= float(texSamples);

        return color;
    }

  it's quite bulky, you might want to use default framebuffer and
  glCopyTexImage2D instead.

-----------
2018.11.12
DMA: direct memory access

by default, gl_FragCoord starts at (0.5, 0.5),  this can be changed by layout
qualifier.

Assume you have two point A, B in clip space, and another point C between them as:
    C = A * (1 - t) + B * t ( xy part)
    If you wan to get perspective correct vertex attribute for C, you must know that:
        1/C_w = (1 - t) / A_w  + t / B_w
        X_w is negative camera space z here.
    With that in mind, you can get perspective correct vertex attribute for C as:
        C_w * (A_x * (1-t) / A_w + B_x * t / B_w)
    check https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes for detail

    The same rule applies for point D inside triangle ABC, you just have to replace t with barycentric coordinates:
        D_w * (A_x * λ0 / A_w + B_x * λ1 / B_w * C_x * λ2 / C_w)

